<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mental Load Dev</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>

  <div id="button" height=50></div>
  <div id="div_template" height=350></div>
  <div id="small_multiples" height=350></div>
  <div id="explain_weights" height=350></div>






  <script>

    // Set up the SVG area and margins
    var margin = { top: 30, right: 20, bottom: 20, left: 60 };
    var width = 400 - margin.left - margin.right;
    var height = 350 - margin.top - margin.bottom;

    var language = "de"

    // append the svg object to the body of the page


    d3.json("data/test_json.json").then(function (data_raw) {
      //#region               ###############      variables   #################
      var all_cats = [];
      if (language == "de") {
        var rhythms_points_mapping_de = {
          "täglich": 4,
          "wöchentlich": 3,
          "monatlich": 2,
          "jährlich": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_de);
      }
      else if (language == "en") {
        var rhythms_points_mapping_en = {
          "daily": 4,
          "weekly": 3,
          "monthly": 2,
          "yearly": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_en);
      }
      const types = ["do_it", "remember"]
      const partner_types = ["partner_does_it", "partner_remembers"]
      //#endregion




      //#region                    ###############      prep and reshape data            #################
      var questions_final = []; //reshaped data
      var quest_ID = 0;
      // target data shape
      // {
      //     "Wäsche waschen + aufhängen": {
      //         "Text": "Wäsche waschen + aufhängen",
      //         "ID": "2",
      //         "domain": "Alle Sorgegemeinschaften, z.B. Paare",
      //         "category":"Haushalt + Wohnen",
      //         "rhythm": "täglich",
      //         "points": "4.00",
      //         "do_it": true,
      //         "remember": false,
      //         "not_apply": false,
      //         "partner_does_it": false,
      //         "partner_remembers": true,
      //         "do_it_and_remember": false
      //     }
      // }
      let domains = Object.keys(data_raw);
      //console.log(domains)
      for (let i = 0; i < domains.length; i++) {
        let obj_cats = data_raw[domains[i]]
        let cats = Object.keys(obj_cats)
        //console.log(obj_cats)
        //console.log(cats)
        for (let catId = 0; catId < cats.length; catId++) {
          let obj_rhthm = obj_cats[cats[catId]]
          let rhthms = Object.keys(obj_rhthm)
          //console.log(obj_rhthm)
          //console.log(rhthms)
          //something[catId] = []
          for (let rhtmID = 0; rhtmID < rhthms.length; rhtmID++) {
            let obj_question = obj_rhthm[rhthms[rhtmID]]
            let questions = Object.keys(obj_question)
            //console.log(obj_question)
            //console.log(questions)
            for (let quesID = 0; quesID < questions.length; quesID++) {
              let obj_ques_level_2 = obj_question[questions[quesID]]
              let ques_level_2 = Object.keys(obj_ques_level_2)
              let obj_arr_answers = obj_ques_level_2[ques_level_2[0]]
              //console.log(obj_ques_level_2)
              //console.log(ques_level_2[0])
              //add question to final array, and some more infos we know
              questions_final[quest_ID[0]] = []
              questions_final.push({})
              questions_final[quest_ID]["Text"] = ques_level_2[0]
              questions_final[quest_ID]["ID"] = questions[quesID]
              questions_final[quest_ID]["domain"] = domains[i]
              questions_final[quest_ID]["category"] = cats[catId]
              questions_final[quest_ID]["rhythm"] = rhthms[rhtmID]
              questions_final[quest_ID]["points"] = rhythms_points_mapping_de[rhthms[rhtmID]]

              //either empty array: partner does it, or object with answers 
              if (Array.isArray(obj_arr_answers)) {
                //console.log("partner does it")
                questions_final[quest_ID]["do_it"] = false;
                questions_final[quest_ID]["remember"] = false;
                questions_final[quest_ID]["partner_does_it"] = true;
                questions_final[quest_ID]["partner_remembers"] = true;
                questions_final[quest_ID]["not_apply"] = false;
                questions_final[quest_ID]["do_it_and_remember"] = false;
                //"do_it_and_remember": false//partner +=1
                //partner_rhm +=1
              }
              else {
                let obj_answers = obj_arr_answers //now an object
                let answers = Object.keys(obj_answers)
                //console.log(answers)
                //console.log(obj_answers)
                if (answers.length == 2) { //no need to go into answers, this must be "done" and "remembered"
                  questions_final[quest_ID]["do_it"] = true;
                  questions_final[quest_ID]["remember"] = true;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = false;
                  questions_final[quest_ID]["do_it_and_remember"] = true;
                }
                else {
                  questions_final[quest_ID]["do_it_and_remember"] = false;
                  let obj_single_answer = obj_answers[answers[0]] //only answer
                  //console.log(obj_single_answer)
                  //console.log(obj_single_answer["answer_type"])
                  switch (obj_single_answer["answer_type"]) {
                    case "1": //"do_it"
                      questions_final[quest_ID]["do_it"] = true;
                      questions_final[quest_ID]["remember"] = false;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = true;
                      break;
                    case "2": //"remember"
                      questions_final[quest_ID]["do_it"] = false;
                      questions_final[quest_ID]["remember"] = true;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = true;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                    case "3": //"not_apply"
                      questions_final[quest_ID]["do_it"] = false;
                      questions_final[quest_ID]["remember"] = false;
                      questions_final[quest_ID]["not_apply"] = true;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                  }
                }
              }
              quest_ID += 1;
            }
          }
        }

      }
      //questions_final.forEach((element) => console.log(element));
      //console.table(questions_final)
      //console.table(questions_final.filter(function(d) {return d.remember == true}))
      let valid_questions = questions_final.filter(function (d) { return d.not_apply == false })
      //console.table(valid_questions)
      let max_num_points = d3.sum(valid_questions, (d) => d.points)

      //print some stats of points
      let remembered_questions = questions_final.filter(function (d) { return d.remember == true })
      let done_questions = questions_final.filter(function (d) { return d.do_it == true })
      let not_apply_questions = questions_final.filter(function (d) { return d.not_apply == true })
      let partner_does_it_questions = questions_final.filter(function (d) { return d.partner_does_it == true })
      let partner_remembers_questions = questions_final.filter(function (d) { return d.partner_remembers == true })
      let remembered_points = d3.sum(remembered_questions, (d) => d.points)
      let done_points = d3.sum(done_questions, (d) => d.points)
      let partner_done_points = d3.sum(partner_does_it_questions, (d) => d.points)
      let partner_remembers_points = d3.sum(partner_remembers_questions, (d) => d.points)
      let number_not_apply = d3.count(not_apply_questions, (d) => d.ID)
      // group by daily, monthly etc. for plots and analysis
      let grouped_by_rhythm = d3.group(valid_questions, d => d.rhythm)

      //console.log(remembered_points)
      console.log("points done: " + done_points + ", points remembered: " + remembered_points +
        ", points done of partner: " + partner_done_points +
        ", points remembered of partner: " + partner_remembers_points +
        ", number not apply: " + number_not_apply +
        ", max sum of points reachable, for each category: " + max_num_points
      )
      // check validity of data
      if (done_points + partner_done_points != remembered_points + partner_remembers_points ||
        done_points + partner_done_points != max_num_points) {
        throw "something is wrong with the dataset"
      }


      // Aggregate data





      //#region                       ##############      setup page    ########
      // Initialize the button
      var dropdownButton = d3.select("#button")
        .append('select')
      dropdownButton // Add a button
        .selectAll('myOptions') // Next 4 lines add 6 options = 6 colors
        .data(rhythms)
        .enter()
        .append('option')
        .text(function (d) { return d; }) // text showed in the menu
        .attr("value", function (d) { return d; })
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      // svg for plotting 
      var svg = d3.select("#div_template")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(types)
        .padding(0.2);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))

      // Add Y axis
      //initial with max number of points for daily tasks
      let filtered_data = grouped_by_rhythm.get(rhythms[0])
      let max_num_of_daily_points = d3.sum(filtered_data, (d) => d.points)
      var y = d3.scaleLinear()
        .domain([0, max_num_of_daily_points])
        .range([height, 0]);
      var yAxis = svg.append("g")
        .attr("class", "myYaxis")
        .call(d3.axisLeft(y));

      //              ##### stacked plot #####
      var svg2 = d3.select("#div_template")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      // X axis
      var x_stacked = d3.scaleBand()
        .range([0, width])
        .domain(partner_types)
        .padding(0.2);
      var xAxis_stacked = svg2.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x_stacked))

      // Add Y axis
      var y_stacked = d3.scaleLinear()
        .domain([0, Math.max(done_points, remembered_points, max_num_points)])
        .range([height, 0]);
      svg2.append("g")
        .attr("class", "myYaxis")
        .call(d3.axisLeft(y_stacked));

      // color palette = one color per subgroup
      var color = d3.scaleOrdinal()
        .domain(rhythms)
        .range(['#e41a1c', '#377eb8', '#4daf4a', '#536745'])

      //              ##### small_multiples plot #####
      //console.table(grouped_by_rhythm)
      let group_test = d3.group(valid_questions, d => d.rhythm, d => d.remember)
      let group_test_do_it = d3.group(valid_questions, d => d.rhythm, d => d.do_it)
      //console.table(group_test.get("täglich"))
      group_test.forEach(function(value,key) {
        value.delete(false)
        let to_rename = value.get(true)
        value.set("remember", to_rename)
        value.delete(true)
        let do_it = group_test_do_it.get(key)
        //console.log(do_it)
        value.set("do_it", do_it.get(true))
        //console.log(value) 
      })
      //console.log(group_test) 
      function myCallback({ quantity }) {
       return quantity > 200 ? "ok" : "low";
      }

      var small_multiples_width = width/2
      var svg_multiples = d3.select("small_multiples")
        .data(group_test)
        .enter()
        .append("svg")
          .attr("width", small_multiples_width + margin.left + margin.right)
          .attr("height", small_multiples_width + margin.top + margin.bottom)
          //.attr("class","multiples_svg")
          //.text(function(d) {console.log(d[0])})
          .text(function(d) {console.log(d);})
        .append("g")
          .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")
          .attr("class", function(d) { return d[0];})

      // X axis
      var x_multiples = d3.scaleBand()
        .range([0, small_multiples_width])
        .domain(types)
        .padding(0.1);
      svg_multiples.append("g")
        .attr("transform", "translate(0," + small_multiples_width + ")")
        .call(d3.axisBottom(x_multiples))

      // Add Y axis
      var y_multiples = d3.scaleLinear()
        .domain([0, 60]) //TODO
        .range([small_multiples_width, 0]);
        svg_multiples.append("g")
        .attr("class", "myYaxis_multiples")
        .call(d3.axisLeft(y_multiples));

      //#endregion


      //#region        ####### vis elements, main ##########


      //build data array for the first time: "daily as initial"
      // console.log(rhythms[0])
      let initial_data = build_data_for_chart(rhythms[0])
      // svg.append("g").attr("class", "content");

      update(initial_data, max_num_of_daily_points);

      var [formattedData, type] = aggregate_data(valid_questions, "me")
      var stack = d3.stack()
          .keys(rhythms)
          .order(d3.stackOrderNone)
          .offset(d3.stackOffsetNone);

        var series = stack(formattedData);
      //console.table(formattedData)
      build_stacked_chart(series, type)

      build_multiples_chart()

      //#endregion

      //#region                            #################   functions ##################

      // A function that create / update the plot for a given variable:
      function update(data, max_points) {

        y.domain([0, max_points]);
        yAxis.transition().duration(1000).call(d3.axisLeft(y));

        var u = svg.selectAll(".content")
          .data(data);
        u.exit().remove();

        var enter = u.enter().append("g").attr("class", "content");
        enter.append("rect").attr("class", "rectangle");
        enter.append("line").attr("class", "myLine");
        enter.append("text").attr("class", "line_label");

        u = u.merge(enter)
        u.select(".rectangle")
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.type); })
          .attr("y", function (d) { return y(d.value); })
          //.text(function(d) {console.log(d.type);})
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", "#69b3a2")

        u.select(".myLine")
          .transition()
          .duration(1000)
          .style("stroke", "grey")
          .style("stroke-dasharray", ("4, 4"))
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", (d) => y(max_points / 2))
          .attr("y2", (d) => y(max_points / 2));

        u.select(".line_label")
          .transition()
          .duration(1000)
          .attr("x", width * (2 / 3))
          .attr("y", (d) => y(max_points / 2))
          .attr("dy", "-.35em")
          .style("font-family", "calibri")
          .style("font-size", "80%")
          .text("50% of points")

      }

      function build_data_for_chart(option) {
        let data_updated = [];
        let filtered_data = grouped_by_rhythm.get(option)
        types.forEach(ty => {
          //key_value[rh]["types"][ty] = {"type":ty, "value": 0};
          let filtered_data_type = filtered_data.filter(function (d) { return d[ty] == true })
          let num_points = d3.sum(filtered_data_type, (d) => d.points)
          data_updated.push({ "type": ty, "value": num_points });
        })
        return data_updated
      }

      dropdownButton.on("change", function (d) {
        // recover the option that has been chosen
        let selectedOption = d3.select(this).property("value")
        // build fitting data
        let data_updated = build_data_for_chart(selectedOption)
        let max_points = d3.sum(grouped_by_rhythm.get(selectedOption), (d) => d.points)
        //console.log(max_points)
        // run the updateChart function with this selected option
        update(data_updated, max_points)
      })

      function build_stacked_chart(series, type) {

        x_stacked.domain(type)
        xAxis_stacked.transition().duration(1000).call(d3.axisBottom(x_stacked));

        svg2.append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(series)
          .enter().append("g")
          .attr("class", "serie")
          .attr("fill", d => color(d.key))
          .selectAll("rect")
          .data(d => d)
          .enter().append("rect")
          .attr("x", d => x_stacked(d.data.type))
          .attr("y", d => y_stacked(d[1]))
          .attr("height", d => y_stacked(d[0]) - y_stacked(d[1]))
          .attr("width", x_stacked.bandwidth());

        const legend = svg2.selectAll(".legend")
          .data(rhythms.slice().reverse())
          .enter().append("g")
          .attr("class", "legend")
          .attr("transform", (d, i) => `translate(0,${i * 20})`);

        legend.append("rect")
          .attr("x", width - 18)
          .attr("width", 18)
          .attr("height", 18)
          .style("fill", color);

        legend.append("text")
          .attr("x", width - 24)
          .attr("y", 9)
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .style("font-family", "calibri")
          .style("font-size", "80%")
          .text(d => d);

      }

      function build_multiples_chart() {

        //svg_multiples.select(".multiples_svg")
        group_test.forEach(function(data, i) {
          //console.log(data, i)
          d3.select("g." + i)
            .selectAll('.bar')
            .data(data)
            .enter()
              .append("rect")
              //.text(function(d) {console.log(d)})
              .attr("x", function (d) { return x_multiples(d[0]); })
              .attr("y", function (d) { return y_multiples(d3.sum(d[1], (s) => s.points));})
              // .text(function(d) {
              //   console.log(d3.sum(d[1], (s) => s.points));
              //   // d3.sum(remembered_questions, (d) => d.points)
              //                   console.log(d)
              // })
              .attr("width", x_multiples.bandwidth())
              .attr("height", function (d) { return small_multiples_width - y_multiples(d3.sum(d[1], (s) => s.points)); })
              .attr("fill", d => color(i) )
        }
      ) 
      }

      // ##### functions for data handling #### 

      function aggregate_data(data, person) {
        switch (person) {
          case "me":
            var type_to_use = types
            break;

          case "partner":
            var type_to_use = partner_types
            break;
        }

        let aggregatedData = {
          [type_to_use[0]]: {},
          [type_to_use[1]]: {}
        };
        data.forEach(d => {
          if (d[type_to_use[0]]) {
            aggregatedData[type_to_use[0]][d.rhythm] = (aggregatedData[type_to_use[0]][d.rhythm] || 0) + d.points;
          }
          if (d[type_to_use[1]]) {
            aggregatedData[type_to_use[1]][d.rhythm] = (aggregatedData[type_to_use[1]][d.rhythm] || 0) + d.points;
          }
        });

        let formattedData = type_to_use.map(type => {
          const obj = { type };
          rhythms.forEach(category => {
            obj[category] = aggregatedData[type][category] || 0;
          });
          return obj;
        });
        

        return [formattedData, type_to_use]
      }
      //#endregion
    })

      .catch(function (error) {
        // handle error
        console.log(error)
      });

  </script>




</body>

</html>