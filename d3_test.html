<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mental Load Dev</title>
  <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<style>
  html * {
    font-family: "Ubuntu" !important;
  }

  body {
    margin-left: 40px; 
  }

  .tooltip {
    position: absolute;
    text-align: center;
    width: auto;
    height: auto;
    padding: 5px;
    font-size: 12px;
    background: #F2F2F2;
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
    visibility: hidden;
    z-index: 1;
    /* Initially hidden */
  }

  .axislabel,
  .tick,
  .annotation,
  .label {
    font-size: 13px;
  }

  .dashed_line {
    stroke: black;
    stroke-dasharray: 4 4;
    stroke-width: 1;
  }

  .chart_title {
    font-size: 18px;
  }

  .grid line {
      stroke: lightgrey;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }
  

  input, label {
    display:block;
    font-size: 14px;
  }

  p {
    max-width: 850px;
    font-size: 14px;
  }

  button {
    
    padding: 5px;
    
    /* background-color: #C8532E; */
    border: 0px;
    border-radius: 2px;
   
    /* Initially hidden */
  }
  button:hover {
    background-color: #C8532E;
  }
  button:active {
    background-color: #cb846f;
  }

  /* .tick {
  font-size: 13px;
} */
</style>

<body>


  <script>

    // Set up the SVG area and margins
    var margin = { top: 50, right: 20, bottom: 20, left: 60 };
    var width = 400 - margin.left - margin.right;
    var height = 350 - margin.top - margin.bottom;

    var language = "en"

    // append the svg object to the body of the page


    d3.json("data/test_json_en.json").then(function (data_raw) {
      //#region               ###############      variables   #################
      var all_cats = [];
      if (language == "de") {
        var rhythms_points_mapping_de = {
          "täglich": 4,
          "wöchentlich": 3,
          "monatlich": 2,
          "jährlich": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_de);
      }
      else if (language == "en") {
        var rhythms_points_mapping_en = {
          "daily": 4,
          "weekly": 3,
          "monthly": 2,
          "yearly": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_en);
      }
      const types = ["I_do_it", "I_remember"]
      const partner_types = ["partner_does_it", "partner_remembers"]


      //#endregion


      //#region                    ###############      prep and reshape data            #################
      var questions_final = []; //reshaped data
      var quest_ID = 0;
      // target data shape
      // {
      //     "Wäsche waschen + aufhängen": {
      //         "Text": "Wäsche waschen + aufhängen",
      //         "ID": "2",
      //         "domain": "Alle Sorgegemeinschaften, z.B. Paare",
      //         "category":"Haushalt + Wohnen",
      //         "rhythm": "täglich",
      //         "points": "4.00",
      //         "I_do_it": true,
      //         "I_remember": false,
      //         "not_apply": false,
      //         "partner_does_it": false,
      //         "partner_remembers": true,
      //         "I_do_it_and_I_remember": false
      //     }
      // }
      let domains = Object.keys(data_raw);
      //console.log(domains)
      for (let i = 0; i < domains.length; i++) {
        let obj_cats = data_raw[domains[i]]
        let cats = Object.keys(obj_cats)
        //console.log(obj_cats)
        //console.log(cats)
        for (let catId = 0; catId < cats.length; catId++) {
          let obj_rhthm = obj_cats[cats[catId]]
          let rhthms = Object.keys(obj_rhthm)
          //console.log(obj_rhthm)
          //console.log(rhthms)
          //something[catId] = []
          for (let rhtmID = 0; rhtmID < rhthms.length; rhtmID++) {
            let obj_question = obj_rhthm[rhthms[rhtmID]]
            let questions = Object.keys(obj_question)
            //console.log(obj_question)
            //console.log(questions)
            for (let quesID = 0; quesID < questions.length; quesID++) {
              let obj_ques_level_2 = obj_question[questions[quesID]]
              let ques_level_2 = Object.keys(obj_ques_level_2)
              let obj_arr_answers = obj_ques_level_2[ques_level_2[0]]
              //console.log(obj_ques_level_2)
              //console.log(ques_level_2[0])
              //add question to final array, and some more infos we know
              questions_final[quest_ID[0]] = []
              questions_final.push({})
              questions_final[quest_ID]["Text"] = ques_level_2[0]
              questions_final[quest_ID]["ID"] = questions[quesID]
              questions_final[quest_ID]["domain"] = domains[i].replace('... ', '')
              questions_final[quest_ID]["category"] = cats[catId]
              questions_final[quest_ID]["rhythm"] = rhthms[rhtmID]
              if (language == "de") {
                questions_final[quest_ID]["points"] = rhythms_points_mapping_de[rhthms[rhtmID]]
              }
              else if (language == "en") {
                questions_final[quest_ID]["points"] = rhythms_points_mapping_en[rhthms[rhtmID]]
              }

              //either empty array: partner does it, or object with answers 
              if (Array.isArray(obj_arr_answers)) {
                //console.log("partner does it")
                questions_final[quest_ID]["I_do_it"] = false;
                questions_final[quest_ID]["I_remember"] = false;
                questions_final[quest_ID]["partner_does_it"] = true;
                questions_final[quest_ID]["partner_remembers"] = true;
                questions_final[quest_ID]["not_apply"] = false;
                questions_final[quest_ID]["I_do_it_and_I_remember"] = false;
                //"I_do_it_and_I_remember": false//partner +=1
                //partner_rhm +=1
              }
              else {
                let obj_answers = obj_arr_answers //now an object
                let answers = Object.keys(obj_answers)
                //console.log(answers)
                //console.log(obj_answers)
                if (answers.length == 2) { //no need to go into answers, this must be "done" and "I_remembered"
                  questions_final[quest_ID]["I_do_it"] = true;
                  questions_final[quest_ID]["I_remember"] = true;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = false;
                  questions_final[quest_ID]["I_do_it_and_I_remember"] = true;
                }
                else {
                  questions_final[quest_ID]["I_do_it_and_I_remember"] = false;
                  let obj_single_answer = obj_answers[answers[0]] //only answer
                  //console.log(obj_single_answer)
                  //console.log(obj_single_answer["answer_type"])
                  switch (obj_single_answer["answer_type"]) {
                    case "1": //"I_do_it"
                      questions_final[quest_ID]["I_do_it"] = true;
                      questions_final[quest_ID]["I_remember"] = false;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = true;
                      break;
                    case "2": //"I_remember"
                      questions_final[quest_ID]["I_do_it"] = false;
                      questions_final[quest_ID]["I_remember"] = true;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = true;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                    case "3": //"not_apply"
                      questions_final[quest_ID]["I_do_it"] = false;
                      questions_final[quest_ID]["I_remember"] = false;
                      questions_final[quest_ID]["not_apply"] = true;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                  }
                }
              }
              quest_ID += 1;
            }
          }
        }

      }
      //questions_final.forEach((element) => console.log(element));
      //console.table(questions_final)
      //console.table(questions_final.filter(function(d) {return d.I_remember == true}))
      let valid_questions = questions_final.filter(function (d) { return d.not_apply == false })
      //console.table(valid_questions)
      let max_num_points = d3.sum(valid_questions, (d) => d.points)

      //print some stats of points
      let I_remembered_questions = questions_final.filter(function (d) { return d.I_remember == true })
      let done_questions = questions_final.filter(function (d) { return d.I_do_it == true })
      let not_apply_questions = questions_final.filter(function (d) { return d.not_apply == true })
      let partner_does_it_questions = questions_final.filter(function (d) { return d.partner_does_it == true })
      let partner_remembers_questions = questions_final.filter(function (d) { return d.partner_remembers == true })
      let I_remembered_points = d3.sum(I_remembered_questions, (d) => d.points)
      let done_points = d3.sum(done_questions, (d) => d.points)
      let partner_done_points = d3.sum(partner_does_it_questions, (d) => d.points)
      let partner_remembers_points = d3.sum(partner_remembers_questions, (d) => d.points)
      let number_not_apply = d3.count(not_apply_questions, (d) => d.ID)
      // group by daily, monthly etc. for plots and analysis
      let grouped_by_rhythm = d3.group(valid_questions, d => d.rhythm)

      const uniqueCategories = Array.from(new Set(valid_questions.map(d => d.category)));
      const uniqueDomains = Array.from(new Set(valid_questions.map(d => d.domain)));
      //console.log(uniqueDomains)
      console.log("points done: " + done_points + ", points I_remembered: " + I_remembered_points +
        ", points done of partner: " + partner_done_points +
        ", points I_remembered of partner: " + partner_remembers_points +
        ", number not apply: " + number_not_apply +
        ", max sum of points reachable, for each category: " + max_num_points
      )
      // check validity of data
      if (done_points + partner_done_points != I_remembered_points + partner_remembers_points ||
        done_points + partner_done_points != max_num_points) {
        throw "something is wrong with the dataset"
      }

      //#endregion

      //#region           ############    colours    ##############
        var mntlld_darkblue = "#0F3D5F"
        var mntlld_lightblue = "#0A92BA"
        var mntlld_green = "#7FB701"
        var mntlld_grey = "#F2F2F2"
        var mntlld_dark_grey = "#ABABAB"
        var mntlld_red = "#C8532E"

        var color = d3.scaleOrdinal()
          .domain(rhythms)
          .range(['#346B91', '#6EA0C4', '#BCDFF7', '#D6EEFF'])


          
        var domainColor = d3.scaleOrdinal()
          .domain(uniqueDomains)
          .range([mntlld_darkblue, mntlld_green, mntlld_red, '#F05B9B'])
      //#endregion
      

      //#region                ##########  main, structure and layout ##########
      console.table(valid_questions)

      var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")
      var stack = d3.stack()
        .keys(categories)
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetNone);

      var series = stack(formattedData);
      // add text
      d3.select("body").append("h1").html("Evaluation")
      d3.select("body").append("div").attr("class", "tooltip")
      var tooltip = d3.select(".tooltip");
      d3.select("body").append("p").html("Here's your score: You have " + done_points + " of " + max_num_points +
      " I-do-it points and " + I_remembered_points + " of " + max_num_points + " I-I_remember-to-do-it points. " +
      "<br> Your total score is " + (I_remembered_points + done_points) + ".")
      build_overview_chart()
      d3.select("body").append("h2").html("Scoring")
      d3.select("body").append("p").html("How are the points calculated? We wanted to weigh the tasks more that are done one a daily basis - in contrast to those which are done only yearly.\n This is explained with your do-it checkmarks that you set in the test:")
      build_explain_weights_chart()
      build_stacked_chart(series, type)
      d3.select("body").append("h2").html("Do you prefer a certain kind of task?")
      build_bar_comparison_charts(grouping = "rhythm")
      build_categories_diverging()
      d3.select("body").append("h2").html("Comparison to partner")
      build_confusion_matrix()
      d3.select("body").append("h2").html("But what about the paid work?")
      build_working_time()
      // build_bar_comparison_charts(grouping = "domain")
      //#endregion



      //#region             ##### build charts functions #####

      function build_overview_chart() {
        d3.select("body").append("div").attr("class", "overview_chart")

        // svg for plotting 
        var svg = d3.select(".overview_chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        var x = d3.scaleBand()
          .range([0, width])
          .domain(types)
          .padding(0.2);


        // Add Y axis
        //initial with max number of points for daily tasks
        var y = d3.scaleLinear()
          .domain([0, 1.1 * max_num_points])
          .range([height, 0]);
        var yAxis = svg.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));

        //yAxis label
        svg.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "end")
          .attr("y", -20)
          .attr("dy", ".75em")
          //.attr("transform", "translate(-40," + height/2 + "),rotate(-90)")
          .text("points");

        let rolled_up_I_do_it = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_do_it)
        let rolled_up_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_remember)
        let data_overview = [
          { "type": "I_do_it", "value": rolled_up_I_do_it.get(true) },
          { "type": "I_remember", "value": rolled_up_I_remember.get(true) },
        ];
        //console.log(data_overview)

        svg.append("g").attr("class", "bars")
          .selectAll("rect")
          .data(data_overview)
          .enter().append("rect")
          //.text(function (d) { console.log(d.type); })
          .attr("x", function (d) { return x(d.type); })
          .attr("y", function (d) { return y(d.value); })
          //.text(function(d) {console.log(d.type);})
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", mntlld_darkblue)
          .on("mouseover", function (event, d) {
            tooltip.style("visibility", "visible").text(d.value + " Points");
            d3.select(this).attr("fill", mntlld_red)
          })
          .on("mousemove", function (event, d) {
            tooltip.style("top", (event.pageY - 10) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", mntlld_darkblue);
            tooltip.style("visibility", "hidden");
          });

        //add bar labels
        svg.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I_do_it" }, { "sum": I_remembered_points, "type": "I_remember" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x(d.type) + x.bandwidth() / 2)
          .attr("y", (d) => y(d.sum))
          .attr("dy", "-1em")
          .style("text-anchor", "middle")
          .text(d => d.sum);

        //add 50% line
        svg.selectAll(".dashed_line")
          .data([max_num_points / 2, max_num_points])
          .enter()
          .append("line")
          .attr("class", "dashed_line")
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", d => y(d))
          .attr("y2", d => y(d));

        //line labels
        svg.append("g").attr("class", "line_labels")
          .selectAll("label")
          .data([
            { "value": max_num_points / 2, "text": "50% of reachable points" },
            { "value": max_num_points, "text": "reachable points: " + max_num_points }
          ])
          .enter()
          .append("text")
          .attr("class", "label")
          .attr("x", width)
          .attr("y", d => y(d.value))
          .attr("dy", "-.35em")
          .style("text-anchor", "end")
          .text(d => d.text)
        
        //x-Axis on top
          svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x))
      }


      function build_explain_weights_chart() {
        d3.select("body").append("div").attr("class", "explain_weights")
        
        
        var svg3 = d3.select(".explain_weights")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("class", "explain_svg")
          .attr("position", "absolute")
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        var x_explain = d3.scaleBand()
          .range([0, width])
          .domain(["I-do-it checkmarks", "I-do-it points"])
          .paddingInner(0.5)
          .paddingOuter(0.5)


        var xAxis_explain = svg3.append("g")
          //.attr("transform", "translate(0,)")
          .call(d3.axisTop(x_explain))
        xAxis_explain.selectAll("path")
          .style("stroke", "none");

        var y_explain = d3.scaleLinear()
          .domain([done_points, 0])
          .range([height, 0]);
        svg3.append("g")
          .attr("transform", "translate(" + (width - 0.8 * x_explain.paddingOuter() * x_explain.step()) + ",0)")
          .call(d3.axisRight(y_explain));

        //aggregate according to points
        var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")


        var stack = d3.stack()
          .keys(categories)
          .order(d3.stackOrderReverse)
          .offset(d3.stackOffsetNone);

        // aggregate by number of checkmarks
        var ticks_by_rhythm = d3.rollup(done_questions, v => v.length, d => d.rhythm)
        let formatted_ticks = {};
        let done_ticks = 0;
        rhythms.forEach(rhythm => {
          formatted_ticks[rhythm] = ticks_by_rhythm.get(rhythm) || 0;
          done_ticks += ticks_by_rhythm.get(rhythm) || 0
        });
        //console.log(done_ticks)
        //join checkmarks and points
        formattedData[1] = formatted_ticks
        var series = stack(formattedData) //stack data
        series.forEach(item => {
          item[0].data["type"] = "I-do-it points"
          item[1].data["type"] = "I-do-it checkmarks"
        })

        // data for lines
        var connection_lines = []
        series.forEach((item, index) => {
          connection_lines[index] = [item[1][1], item[0][1]]
        })
        var fraction_lines = []
        let i = 0;
        series.forEach((item, index) => {
          switch (item.key) {
            case rhythms[3]: //yearly
              // fraction_lines[i] = item[0][1]
              // i++;
              break;
            case rhythms[2]: //monthly
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              i += 1;
              break;
            case rhythms[1]: //weekly
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              fraction_lines[i + 1] = item[0][0] + 2 * (item[1][1] - item[1][0])
              i += 2;
              break;
            case rhythms[0]: //daily
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              fraction_lines[i + 1] = item[0][0] + 2 * (item[1][1] - item[1][0])
              fraction_lines[i + 2] = item[0][0] + 3 * (item[1][1] - item[1][0])
              i += 3;
              break;
            default:
              break;
          }
          //fraction_lines[i]=[item[1][1], item[0][1]]

        })

        //rectangles
        svg3.append("g").attr("class", "rectangles")
          .selectAll("g")
          .data(series)
          .enter().append("g")
          .attr("class", d => "rects_" + d.key)
          .each(function(parentData) {
            d3.select(this)
            .selectAll("rect")
            .data(d => d)
            .enter().append("rect")
            .attr("fill", d => color(parentData.key))
            .attr("x", d => x_explain(d.data.type))
            .attr("y", d => y_explain(d[0]))
            .attr("height", d => y_explain(d[1]) - y_explain(d[0]))
            //.text(function(d) {console.log(parentData)})
            .attr("width", x_explain.bandwidth())
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(
                  d.data.type == "I-do-it checkmarks" ? (d[1] - d[0]) + " checkmarks" : (d[1] - d[0]) + " points");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", color(parentData.key));
              })
          });

        //lines
        svg3
          .append("g").attr("class", "connection_lines")
          .selectAll("line.connection_line")
          .data(connection_lines)
          .enter()
          .append("line")
          .attr("class", "connection_line")
          //.text(function(d) {console.log(d)})
          .style("stroke", "black")
          .attr("x1", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner() * x_explain.step())
          .attr("y1", (d) => y_explain(d[0]))
          .attr("y2", (d) => y_explain(d[1]));

        svg3.append("g").attr("class", "fraction_lines")
          .selectAll("line.fraction_line")
          .data(fraction_lines)
          .enter()
          .append("line")
          .attr("class", "dashed_line")
          //.text(function(d) {console.log(d)})
          // .style("stroke", "black")
          // .style("stroke-dasharray", ("4, 4"))
          // .style("stroke-width", 0.5)
          // .attr("x1", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          // .attr("x2", x_explain.paddingOuter()*x_explain.step() + 2*x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          .attr("x1", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter() * x_explain.step() + 2 * x_explain.bandwidth() + x_explain.paddingInner() * x_explain.step())
          .attr("y1", (d) => y_explain(d))
          .attr("y2", (d) => y_explain(d));

        svg3.append("g").attr("class", "annotation")
          .selectAll("text.multiplier")
          .data(series)
          .enter()
          .append("text")
          .attr("class", "multiplier")
          .attr("x", width / 2)
          .attr("y", (d) => y_explain(((d[1][0] + (d[1][1] - d[1][0]) / 2) + (d[0][0] + (d[0][1] - d[0][0]) / 2)) / 2))
          .attr("dy", ".35em")
          .style("text-anchor", "middle")
          .text(d => "x" + (d.index + 1));

        svg3.append("g").attr("class", "label")
          .selectAll("text.legend")
          .data(series)
          .enter()
          .append("text")
          .attr("class", "legend")
          //.text(function(d) {console.log(d)})
          .attr("x", x_explain.paddingOuter() * x_explain.step())
          .attr("y", (d) => y_explain(d[1][0] + (d[1][1] - d[1][0]) / 2))
          .attr("dx", "-.35em")
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .text(d => d.key);

        svg3.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I-do-it points" }, { "sum": done_ticks, "type": "I-do-it checkmarks" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x_explain(d.type) + x_explain.bandwidth() / 2)
          .attr("y", (d) => y_explain(d.sum))
          .attr("dy", "1.2em")
          .style("text-anchor", "middle")
          .text(d => d.sum);
      }


      function build_confusion_matrix() {
        d3.select("body").append("div").attr("class", "confusion_matrix")
     
        d3.select(".confusion_matrix").append("p").html("Your partner does all the tasks that you don't do. " +
       "And your partner remembers all the tasks you don't remember. <br> Each circle is one task.").style("display", "block")
    

        var conf_margin = { top: 30, right: 400, bottom: 20, left: 20 };
        var conf_width = 1200 - conf_margin.left - conf_margin.right;
        var conf_height = 400 - conf_margin.top - conf_margin.bottom;


        const innerWidth = conf_width - conf_margin.left - conf_margin.right;
        const innerHeight = conf_height - conf_margin.top - conf_margin.bottom;

        const x_confusion = d3.scaleBand()
          .domain(['I_remember', 'partner_remembers'])
          .range([0, innerWidth]);

        const y_confusion = d3.scaleBand()
          .domain(['I_do_it', 'partner_does_it'])
          .range([0, innerHeight]);

        const svg_confusion = d3.select(".confusion_matrix")
          .append("svg")
          .attr("width", conf_width)
          .attr("height", conf_height)
          .append("g")
          .attr("transform", `translate(${conf_margin.left},${conf_margin.top})`);

        // Add column labels
        svg_confusion.selectAll(".column-label")
          .data(x_confusion.domain())
          .enter().append("text")
          .attr("class", "column-label")
          .attr("x", d => x_confusion(d) + x_confusion.bandwidth() / 2)
          .attr("y", -10) // Position above the grid
          .attr("text-anchor", "middle")
          .text(d => d);

        // Add row labels
        svg_confusion.selectAll(".row-label")
          .data(y_confusion.domain())
          .enter().append("text")
          .attr("class", "row-label")
          .attr('transform', d => 'translate(' + -10 + ',' + (y_confusion(d) + y_confusion.bandwidth() / 2) + '),' + 'rotate(-90)')
          //.text(function(d) {console.log(y_confusion.bandwidth() / 2)})
          .attr("text-anchor", "middle")
          .attr("dy", "0.35em") // Vertical alignment
          .text(d => d);

        // calculate radius based on points
        const radiusScale = d3.scaleSqrt()
          .domain([0, d3.max(valid_questions, d => d.points)])
          .range([0, 10]);

        // Map data to cell positions
        const mappedData = valid_questions.map(d => ({
          ...d,
          x: x_confusion(d.I_remember ? "I_remember" : "partner_remembers") + x_confusion.bandwidth() / 2,
          y: y_confusion(d.I_do_it ? "I_do_it" : "partner_does_it") + y_confusion.bandwidth() / 2,
          r: radiusScale(d.points)
        }));

        // Create simulation
        const simulation = d3.forceSimulation(mappedData)
          .force("x", d3.forceX(d => d.x).strength(1))
          .force("y", d3.forceY(d => d.y).strength(1))
          .force("collide", d3.forceCollide(d => d.r))
          .stop();

        for (let i = 0; i < 500; ++i) simulation.tick(); // Run the simulation
        // Draw points
        svg_confusion.append("g").selectAll(".point")
          .data(mappedData)
          .enter().append("circle")
          .attr("class", "point")
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
          .attr("r", d => d.r)
          .attr("fill", d => domainColor(d.domain))
          .on("mouseover", function (event, d) {
            tooltip.style("visibility", "visible").text(d.Text);
            d3.select(this).attr("fill", mntlld_dark_grey)
          })
          .on("mousemove", function (event, d) {
            tooltip.style("top", (event.pageY - 10) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", domainColor(d.domain));
            tooltip.style("visibility", "hidden");
          });


        // legend
        const legend = svg_confusion.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${innerWidth + 40}, 20)`);

        // Add size legend
        const sizeLegend = legend.append("g")
          .attr("class", "size-legend");

        sizeLegend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .text("Size (Frequency):")
          .style("font-size", "12px")
          .style("font-weight", "bold");

        const sizeValues = [...new Set(valid_questions.map(d => d.points))];

        sizeLegend.selectAll("circle")
          .data(sizeValues)
          .enter().append("circle")
          .attr("cx", 10)
          .attr("cy", (d, i) => 20 + i * 25)
          .attr("r", d => radiusScale(d))
          .attr("fill", mntlld_dark_grey)
          //.attr("stroke", "darkgrey");

        sizeLegend.selectAll("text.size-label")
          .data(sizeValues)
          .enter().append("text")
          .attr("class", "size-label")
          .attr("x", 30)
          .attr("y", (d, i) => 20 + i * 25)
          .attr("dy", "0.35em")
          .style("font-size", "12px")
          .text(d => rhythms[Math.abs(d - 4)]);

        // Add color legend
        const colorLegend = legend.append("g")
          .attr("class", "color-legend")
          .attr("transform", "translate(0, 150)");

        colorLegend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .text("Colour (Domain):")
          .style("font-size", "12px")
          .style("font-weight", "bold");

        const domainValues = [...new Set(valid_questions.map(d => d.domain))];

        colorLegend.selectAll("rect")
          .data(domainValues)
          .enter().append("rect")
          .attr("x", 10)
          .attr("y", (d, i) => 20 + i * 20)
          .attr("width", 10)
          .attr("height", 10)
          .attr("fill", d => domainColor(d));

        colorLegend.selectAll("text.color-label")
          .data(domainValues)
          .enter().append("text")
          .attr("class", "color-label")
          .attr("x", 30)
          .attr("y", (d, i) => 25 + i * 20) // Adjust y to vertically center with the rect
          .attr("dy", "0.35em")
          .text(d => d)
          .style("font-size", "12px"); // Ensure the text size is visible

      }


      function build_stacked_chart(series, type) {

        var svg2 = d3.select(".explain_weights")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("transform",
            "translate(" + margin.left + ",0)")
          .attr("class", "stacked_svg")
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        var x_stacked = d3.scaleBand()
          .range([0, width])
          .domain(type)
          .padding(0.2);
        var xAxis_stacked = svg2.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x_stacked))

        // Add Y axis
        var y_stacked = d3.scaleLinear()
          .domain([0, Math.max(done_points, I_remembered_points) + 20])
          .range([height, 0]);
        svg2.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y_stacked));
        svg2.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "end")
          .attr("y", -20)
          .attr("dy", ".75em")
          //.attr("transform", "translate(-40," + height/2 + "),rotate(-90)")
          .text("points");


        svg2.append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(series)
          .enter().append("g")
          .attr("class", d => "rects_" + d.key)
          .each(function(parentData) {
            d3.select(this)
            .selectAll("rect")
            .data(d => d)
            .enter().append("rect")
            .attr("fill", d => color(parentData.key))
            .attr("class", "serie")
            .attr("x", d => x_stacked(d.data.type))
            .attr("y", d => y_stacked(d[1]))
            //.text(function(d) {console.log(d)})
            .attr("height", d => y_stacked(d[0]) - y_stacked(d[1]))
            .attr("width", x_stacked.bandwidth())
            .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text((d[1] - d[0]) + " points");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", color(parentData.key));
              });
            });

        svg2.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I_do_it" }, { "sum": I_remembered_points, "type": "I_remember" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x_stacked(d.type) + x_stacked.bandwidth() / 2)
          .attr("y", (d) => y_stacked(d.sum))
          .attr("dy", "-1em")
          .style("text-anchor", "middle")
          .text(d => d.sum);

        //title
        svg2
          .append("text")
          .attr("class", "chart_title")
          .attr("x", (width / 2))
          .attr("y", -30)
          .attr("text-anchor", "middle")
          .text("composition of points");
        // legend

        let legend = svg2.append("g")
          .attr("class", "legend")
          .attr("transform", `translate( ${width - 18} , 0)`);

        legend.append("g").attr("class", "legend_rectangles")
          .selectAll("rect")
          .data(rhythms.slice().reverse())
          .enter().append("rect")
          .attr("transform", (d, i) => `translate(0, ${i * 20})`)
          .attr("width", 18)
          .attr("height", 18)
          .style("fill", color);


        legend.append("g").attr("class", "legend_text")
          .selectAll("text")
          .data(rhythms.slice().reverse())
          .enter().append("text")
          .attr("transform", (d, i) => `translate(-5, ${i * 20 + 9})`)
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .style("font-size", "80%")
          .text(d => d)

      }


      function build_multiples_chart(grouping) {

        //prep data
        let grouped_data = d3.group(valid_questions, d => d[grouping], d => d.I_remember)
        let grouped_I_do_it_data = d3.group(valid_questions, d => d[grouping], d => d.I_do_it)
        //console.log(grouped_I_do_it_data)
        //console.table(group_test.get("täglich"))
        let I_do_it_points = []
        let I_remember_points = []

        grouped_data.forEach(function (value, key) {
          value.delete(false)
          let to_rename = value.get(true)
          if (!to_rename) { to_rename = [{ "points": 0 }] }
          value.set("I_remember", to_rename)
          value.delete(true)
          let I_do_it = grouped_I_do_it_data.get(key)
          if (!I_do_it) { I_do_it = [{ "points": 0 }] }
          value.set("I_do_it", I_do_it.get(true))
          I_do_it_points.push(d3.sum(value.get("I_do_it"), (d) => d.points))
          I_remember_points.push(d3.sum(value.get("I_remember"), (d) => d.points))

        })
        // console.log(grouped_data)

        // create svg
        var width = width / 2
        d3.select("body").append("div").attr("class", grouping + "_small_multiples")
        var svg_multiples = d3.select("." + grouping + "_small_multiples")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
          .enter()
          .append("svg")
          .attr("class", "small_multiples_svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", width + margin.top + margin.bottom)
          // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
          //.text(function(d) {console.log(d);})
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")
          .attr("class", function (d) { return remove_weird_symbols(d[0]); })

        // X axis
        var x_multiples = d3.scaleBand()
          .range([0, small_multiples_width])
          .domain(types)
          .padding(0.1);
        svg_multiples.append("g")
          .attr("transform", "translate(0," + small_multiples_width + ")")
          .call(d3.axisBottom(x_multiples))


        // Add Y axis
        var y_multiples = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 1])
          .range([small_multiples_width, 0]);
        svg_multiples.append("g")
          .attr("class", "myYaxis_multiples")
          .call(d3.axisLeft(y_multiples));
        let grouped_by_grouping = d3.group(valid_questions, d => d[grouping])

        grouped_data.forEach(function (data, i) {
          let max_points = d3.sum(grouped_by_grouping.get(i), (d) => d.points)
          let classname = remove_weird_symbols(i);
          d3.select("g." + classname)
            .selectAll('.bar')
            .data(data)
            .enter()
            .append("rect")
            //.text(function(d) {console.log(d)})
            .attr("x", function (d) { return x_multiples(d[0]); })
            .attr("y", function (d) { return y_multiples((d3.sum(d[1], (s) => s.points)) / max_points) })
            // .text(function(d) {
            //    console.log((d3.sum(d[1], (s) => s.points)/max_points));
            //   d3.sum(I_remembered_questions, (d) => d.points)
            //                   //  console.log(d)
            //  })
            .attr("width", x_multiples.bandwidth())
            .attr("height", function (d) { return small_multiples_width - y_multiples((d3.sum(d[1], (s) => s.points)) / max_points); })
            .attr("fill", function (d) { return grouping == "domain" ? domainColor(i) : color(i) });

          //console.log(max_points)

          d3.select("g." + classname)
            .append("line")
            .attr("class", "some_line")
            //.text(function(d) {console.log(d)})
            .style("stroke", "grey")
            .attr("x1", 0)
            .attr("x2", small_multiples_width)
            .attr("y1", (d) => y_multiples(max_points))
            .attr("y2", (d) => y_multiples(max_points));

          //title
          d3.select("g." + classname)
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (small_multiples_width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);

          d3.select("g." + classname).append("text")
            .attr("x", small_multiples_width * (1 / 2))
            .attr("y", (d) => y_multiples(max_points))
            .attr("dy", "-.35em")
            .attr("text-anchor", "middle")
            .style("font-family", "calibri")
            .style("font-size", "80%")
            .text("max reachable points")

        })
      }

      function build_bar_comparison_charts(grouping) {
        d3.select("body").append("div").attr("class", grouping + "_bar_comp")
        d3.select("." + grouping + "_bar_comp").append("h3").html("By frequency of tasks")

        let margin = { top: 50, right: 20, bottom: 40, left: 60 };
        let width = 400 - margin.left - margin.right;
        let height = 250 - margin.top - margin.bottom;
        
        //prep data
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d => d[grouping])
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_do_it, d => d[grouping])
        let grouped_data = new Map();
        grouped_data.set("I_do_it", normaliseMap(grouped_I_do_it_data));
        grouped_data.set("I_remember", normaliseMap(grouped_data_I_remember));
  

        // create svg
      
        
        let svg_multiples = d3.select("." + grouping + "_bar_comp")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
          .enter()
          .append("svg")
          .attr("class", "small_multiples_svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", function (d) { return (grouping + "_" + remove_weird_symbols(d[0])); })

        let x_axis_grouping;
        switch (grouping) {
          case "domain":
            x_axis_grouping = uniqueDomains
            break;
            case "rhythm":
            x_axis_grouping = rhythms
            break;
 
        }
        // X axis
        let x_multiples = d3.scaleBand()
          .range([0, width])
          .domain(x_axis_grouping)
          .padding(0.1);


        // Add Y axis
        let y_multiples = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 100])
          .range([height, 0]);
        svg_multiples.append("g")
          .attr("class", "myYaxis_multiples")
          .call(d3.axisLeft(y_multiples));
        

        grouped_data.forEach(function (data, i) {
          let classname = remove_weird_symbols(i);
          d3.select("g." + grouping + "_" +  classname)
            .selectAll('.bar')
            .data(data)
            .enter()
            .append("rect")
            //.text(function(d) {console.log(d)})
            .attr("x", function (d) { return x_multiples(d[0]); })
            .attr("y", function (d) { return y_multiples(d[1]); })
            // .text(function(d) {
            //    console.log((d3.sum(d[1], (s) => s.points)/max_points));
            //   d3.sum(I_remembered_questions, (d) => d.points)
            //                   //  console.log(d)
            //  })
            .attr("width", x_multiples.bandwidth())
            .attr("height", function (d) { return height - y_multiples(d[1]); })
            .attr("fill", function (d) { return grouping == "domain" ? domainColor(d[0]) : color(d[0]) });

          //console.log(max_points)
          let g_of_grouping = d3.select("g." + grouping + "_" +  classname)
          
          //dashed line
          g_of_grouping
            .append("line")
            .attr("class", "dashed_line")
            //.text(function(d) {console.log(d)})
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", (d) => y_multiples(50))
            .attr("y2", (d) => y_multiples(50));
          
          //line label
          g_of_grouping
            .append("text")
            .attr("class", "label")
            .attr("x", width)
            .attr("y", (d) => y_multiples(50))
            .attr("dy", "-.35em")
            .attr("text-anchor", "end")
            .text("50%")

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);


          //yAxis label
          g_of_grouping.append("text")
            .attr("class", "y axislabel")
            .attr("text-anchor", "end")
            //.attr("y", -20)
            .attr("dy", ".75em")
            .attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points, in %");

          })

          //x-Axis
          svg_multiples.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x_multiples))
      }
      
    // ####################################################################################################################
    function build_categories_chart() {
      d3.select("body").append("div").attr("class", "categories_chart")
      d3.select(".categories_chart").append("h3").html("By task categories")
        


        //prep data
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d => d.domain, d => d.category)
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_do_it,  d => d.domain, d => d.category)
      
        let grouped_data = new Map();
        grouped_data.set("I_do_it", sortInnerMaps(normaliseMap(grouped_I_do_it_data)));
        grouped_data.set("I_remember", sortInnerMaps(normaliseMap(grouped_data_I_remember)));
        // get categories in correct order
        let categories_sorted_do_it = [];
        grouped_data.get("I_do_it").forEach(function(item) {
          for (let innerKey of item.keys()) {
            categories_sorted_do_it.push(innerKey)
          }
        })
        let categories_sorted_remember = [];
        grouped_data.get("I_remember").forEach(function(item) {
          for (let innerKey of item.keys()) {
            categories_sorted_remember.push(innerKey)
          }
        })
        //console.log(categories_sorted_remember)
        //d3.sort(grouped_data.get("I_do_it"), (d) => d.value)
        //console.log(d3.ascending(grouped_data.get("I_do_it").get("All care-communities, for example couples")))
        
        // create svg
        let margin = { top: 50, right: 20, bottom: 40, left: 250 };
        let width = 400 - margin.left - margin.right;
        let height = 250 - margin.top - margin.bottom;

        
        let svg_multiples = d3.select(".categories_chart")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
            .enter()
            .append("svg")
            .attr("class", "small_multiples_svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", width + margin.top + margin.bottom)
            // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
            //.text(function(d) {console.log(d[0]);})
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", function (d) { return remove_weird_symbols(d[0]); })
        

        // Add X axis
        let x = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 100])
          .range([ 0, width]);

        
        // Y axis
        // let fy = d3.scaleBand()
        //   .range([0, height])
        //   .domain(uniqueDomains)
        //   .padding(0.1);
        // console.log(fy.bandwidth())

        let y_do_it = d3.scaleBand()
          .range([0, height])
          .domain(categories_sorted_do_it)
          .padding(0.05);
        
        let y_remember = d3.scaleBand()
          .range([0, height])
          .domain(categories_sorted_remember)
          .padding(0.05);

        // svg_multiples.append("g")
        //   .attr("transform", "translate(0,0)")
        //   .call(d3.axisLeft(fy))



        grouped_data.forEach(function (data, i) {
          //console.log(data)
          let classname = remove_weird_symbols(i);
          

          let test = d3.select("g." + remove_weird_symbols(i))
            .selectAll('g.group')
            .data(data)
            .enter()
            .append("g")
            // .attr("transform", (d, i) => `translate(0,${5*i})`)
            .attr("class", "group")
            //.text(function(d) {console.log(d[0])})
            .attr("fill", function (d) { return domainColor(d[0]) })
            .selectAll('rect')
            .data(([,d]) => d)
            .enter()
              .append('rect')
              // .text(function(d) {console.log(d)})
              // .text(function(d) {console.log(d)})
              .attr("x", 0)
              .attr("y", function (d) { return i == "I_do_it" ?  y_do_it (d[0]) : y_remember(d[0]) })
            // // .text(function(d) {
            // //    console.log((d3.sum(d[1], (s) => s.points)/max_points));
            // //   d3.sum(I_remembered_questions, (d) => d.points)
            // //                   //  console.log(d)
            // //  })
            .attr("height", y_do_it.bandwidth())
            .attr("width", function (d) { return x(d[1]); })
            // .attr("fill", function (d) { return domainColor(i) });
            //console.log(test)

          let g_of_grouping = d3.select("g." + remove_weird_symbols(i))
          
            //dashed line
          g_of_grouping
            .append("line")
            .attr("class", "dashed_line")
            //.text(function(d) {console.log(d)})
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", (d) => x(50))
            .attr("x2", (d) => x(50));
          
          // //line label
          // g_of_grouping
          //   .append("text")
          //   .attr("class", "label")
          //   .attr("x", height)
          //   .attr("x", (d) => x(50))
          //   .attr("dy", "-.35em")
          //   .attr("text-anchor", "end")
          //   .text("50%")

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);


          //yAxis label
          g_of_grouping.append("text")
            .attr("class", "y axislabel")
            .attr("text-anchor", "end")
            .attr("y", (height + 25))
            .attr("x", (width))
            .attr("dy", ".75em")
            //.attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points, in %");

          switch (i) {
            case "I_do_it":
            g_of_grouping.append("g")
              .attr("transform", "translate(0,0)")
              .call(d3.axisLeft(y_do_it))
              break;

              case "I_remember":
              g_of_grouping.append("g")
              .attr("transform", "translate(0,0)")
              .call(d3.axisLeft(y_remember))
              break;
          
            default:
              break;
          }
        })

        //add x_axis

        svg_multiples.append("g")
          .attr("transform", "translate(0," + (height) + ")")
          .call(d3.axisBottom(x));
        


      }
      
      function build_categories_diverging() {
        d3.select("body").append("div").attr("class", "categories_diverging")
        d3.select(".categories_diverging").append("h3").html("By task categories")
        
        let margin = { top: 80, right: 400, bottom: 0, left: 230 };
        let width = 1000 - margin.left - margin.right;
        let height = 420 - margin.top - margin.bottom;
        
        //prep data
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => (d.points * (-1))),  d => d.I_do_it, d=> d.domain, d => d.category)
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d=> d.domain, d => d.category)
        //console.log(grouped_I_do_it_data)
        
        let grouped_data = new Map();
        grouped_data.set("I_do_it", normaliseAndSpecify(grouped_I_do_it_data));
        grouped_data.set("I_remember", normaliseAndSpecify(grouped_data_I_remember));
        // console.log(grouped_data)
        
        // create svg
        let svg_multiples = d3.select(".categories_diverging")
            .append("svg")
            .attr("class", "small_multiples_svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", width + margin.top + margin.bottom)
            // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
            //.text(function(d) {console.log(d[0]);})
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", "group_diverging")

        

        // Add X axis scale
        let x = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([-100, 100])
          .range([ 0, width]);


        let y = d3.scaleBand()
          .range([0, height])
          .domain(uniqueCategories)
          .padding(0.05);

        //add grid lines

          
          
          d3.select(".group_diverging")
            .selectAll("g")
            .data(grouped_data).enter()
              .append("g")
              .attr("class", d => "group_" + d[0])
              // .text(function(d) {console.log(d[0])}) //I do it and remember
              .selectAll("g")
              .data(([,d]) => d).enter()
                .append("g", d => "group_" + d[0]) //domains
                .attr("fill", function (d) { return domainColor(d[0]) })
                .selectAll('rect')
                .data(([,d]) => d).enter() //categories
                  .append('rect')
                    .attr("x", d => (x(d[1][0])))
                    .attr("y", d => y(d[0]) )
                    .attr("height", y.bandwidth())
                    .attr("width", d => ((x(Math.max(Math.abs(d[1][0]), Math.abs(d[1][1])))) - x(0)))
                    .on("mouseover", function (event, d) {
                      tooltip.style("visibility", "visible").text(Math.max(Math.abs(d[1][0]), Math.abs(d[1][1])) + "%");
                      d3.select(this)
                        .attr("fill-opacity", "0.7")
                    })
                    .on("mousemove", function (event, d) {
                      tooltip.style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                    })
                    .on("mouseout", function (event, d) {
                      d3.select(this).attr("fill-opacity", "1");
                      tooltip.style("visibility", "hidden");
                    });
                    // .text(function(d) {console.log(d)})
                    // .text(function(d) {console.log(Math.abs((d[1][0])))})
                    //.text(function(d) {console.log(d[1])})
                  // .attr("fill", function (d) { return domainColor(i) });

        let g_of_grouping = d3.select("g.group_diverging")

        //add grid
        g_of_grouping
          .insert("g",":first-child") //behind the bars
          .attr("class", "grid")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x)
                  .ticks(width / 50)
                  .tickSize(-height)
                  .tickFormat(""))
          .call(g => g.select(".domain").remove());
          
          //middle line
          g_of_grouping.append("g").attr("class", "lines")
            .append("line")
            .attr("class", "zero_line")
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", (d) => x(0))
            .attr("x2", (d) => x(0));
            
            //dashed line
            g_of_grouping.select(".lines")
            .selectAll(".dashed_line")
            .data([-50, 50]).enter()
            .append("line")
            .attr("class", "dashed_line")
            .attr("stroke", "black")
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", (d) => x(d))
            .attr("x2", (d) => x(d));
          
          // //line label
          // g_of_grouping
          //   .append("text")
          //   .attr("class", "label")
          //   .attr("x", height)
          //   .attr("x", (d) => x(50))
          //   .attr("dy", "-.35em")
          //   .attr("text-anchor", "end")
          //   .text("50%")

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (0))
            .attr("y", 0 - (margin.top))
            .attr("dy", "1em")
            .attr("text-anchor", "middle")
            .text("Share of points by category");


  
        //add x_axis
        svg_multiples.append("g")
            .attr("transform", `translate(0,${0})`)
          .call(d3.axisTop(x)
              .ticks(width / 50)
              .tickFormat(d => (Math.abs(d) + "%"))
              .tickSizeOuter(0))
          .call(g => g.select(".domain").remove())
          .call(g => g.append("text")
              .attr("class", "x axislabel")
              .attr("x", x(50))
              .attr("y", -28)
              .attr("fill", "currentColor")
              .attr("text-anchor", "middle")
              .style("font-size", "150%")
              .text("I remember"))
          .call(g => g.append("text")
              .attr("class", "x axislabel")
              .attr("x", x(-50))
              .attr("y", -28)
              .attr("fill", "currentColor")
              .attr("text-anchor", "middle")
              .style("font-size", "150%")
              .text("I do it"));
          
          //xAxis label
          g_of_grouping.append("text")
            .attr("class", "x axislabel")
            .attr("text-anchor", "end")
            .attr("y", (height + 15))
            .attr("x", (width))
            //.attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points");
   
          
          // svg_multiples.append("g").attr("class", "y_axis")
          // .attr("transform", "translate(0,0)")
          // .call(d3.axisLeft(y))
          // .call(g => g.select(".domain").remove());
        
        //y-Axis
        g_of_grouping.append("g")
          .attr("transform", "translate(-10,0)")
          .call(d3.axisLeft(y)
            .tickSize(0))
          .call(g => g.select(".domain").remove())
          ;

        // legend
        const legend = svg_multiples.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${width + 40}, 20)`);


          legend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .text("Colour (Domain):")
          .style("font-size", "12px")
          .style("font-weight", "bold");

          legend.selectAll("rect")
          .data(uniqueDomains)
          .enter().append("rect")
          .attr("x", 10)
          .attr("y", (d, i) => 20 + i * 20)
          .attr("width", 10)
          //.text(function(d) {console.log(d)})
          .attr("height", 10)
          .attr("fill", d => domainColor(d));

          legend.selectAll("text.color-label")
          .data(uniqueDomains)
          .enter().append("text")
          .attr("class", "color-label")
          .attr("x", 30)
          .attr("y", (d, i) => 25 + i * 20) 
          .attr("dy", "0.35em")
          .text(d => d)
          .style("font-size", "12px"); 

        


      }
      
      function build_working_time() {
        var total_percentage = 0.5; //start with 50/50 distribution
        let input_data = [
          {"text": "Person 1: Working hours per week", "value": 40, "id":"Person1"},
          {"text": "Hours children in childcare per day", "value": 8, "id":"Childcare"},
          {"text": "Person 2: Working hours per week", "value": 20, "id":"Person2"}
        ]

        var numbers = [];
        var sum = 0;

        
        let margin = { top: 50, right: 40, bottom: 40, left: 20 };
        let width = 400 - margin.left - margin.right;
        let height = 150 - margin.top - margin.bottom;
      
        // colours
        let work_colour = d3.scaleOrdinal()
          .domain(input_data.map(item => item.id))
          .range([mntlld_lightblue, mntlld_grey, mntlld_green])
        let work_division_colour_ids = ["Person1-PaidWork", "Person1-Childcare",
                                         "Person2-Childcare", "Person2-PaidWork"];
        let work_division_colour = d3.scaleOrdinal()
          .domain(work_division_colour_ids)
          .range([mntlld_lightblue, "#7EC2D6", "#B9D57A", mntlld_green])

        //start appending

        let div = d3.select("body").append("div").attr("class", "working_time").style("display", "block")
        div.append("p").style("display", "block")
          .html("Mental Load is difficult to measure in time since it's often in parallel of performing other tasks. "
           + "But we can take the example of childcare to visualise the impact of different amounts of paid work " + 
           "on care work. <br>A typical week of childcare has 7x14h = 98h when children do not go to daycare or school. ")

        let input_group = div.append("div")
          .attr("class", "inputs")
          .style("float", "left")
          .style("margin-top", "10px")
          .style("margin-bottom", "10px")
          .style("width", "100%")


        //append inputs
        input_group.selectAll("div")
          .data(input_data).enter()
          .append("div")
            .attr("class", d => d.text)
              .style("float", "left")
              .style("margin-right", "20px")
            .append("input")
              .attr("class", "text_input")
              .attr("type", "number")
              .attr("placeholder", "e.g. 40")
              .attr("min", 0)
              .attr("value", d => d.value)
              .attr("id", d => d.id)
              .style("margin", "12px 0px")
              .on("change", function() {
                numbers = [];
                sum = 0;
                load_hours_overview()
                load_hours_division()
              })
            
        input_group.selectAll("div")
          .insert("label", ":first-child")
            .attr("for", d => d.id)
            .text(d=> d.text)

        div.append("p")
          .attr("class", "summarise_input")
          .style("display", "block")

        

        div.append("svg")
          .attr("class", "working_svg")
          .style("display", "block")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("class", "working_hours")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")

        div.append("p")
          .attr("class", "between_svgs")
          .style("display", "block")
        
        div.append("div").attr("class", "division_div")
        .style("width", "100%")
        .style("float", "left")
        .style("display", "block");

        d3.select(".division_div").append("svg")
          .attr("class", "division_svg")
          .style("float", "left")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("class", "working_division")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
          
        d3.select(".division_div").append("button")
          .attr("type", "button")
          .text("Reset to 50:50")
          .style("margin-top", margin.top + "px")
          .on("click", function() {
            total_percentage = 0.5;
            numbers = [];
            sum = 0;
            load_hours_overview();
            load_hours_division();});
              
        d3.select(".division_div").append("p")
        .attr("class", "hint")
        .style("font-size", "10px")
        .text("try moving the division line");
        
        div.append("p")
        .attr("class", "concl_division")
        .style("display", "block");
        

        
          d3.select(".working_svg").append("svg:defs")
            .selectAll("marker")
            .data(["start-arrow", "end-arrow"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("viewBox", "0 -5 10 10")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 -5 L 0 5")
            .style("stroke", "black")
            .style("stroke-width", 3);

          let x = d3.scaleLinear()
            .range([ 0, width]);
        
        
        load_hours_overview()
        load_hours_division()

        function load_hours_overview (){
        
          //working hours bar chart
          
          let stacked = [];
          for (let i = 0; i < 3; i++) {
            let value = Number(d3.select("#" + input_data[i].id).property("value"))
            
            if (i == 1) {//special calculation for childcare
              value = 98 - (5*value)
              stacked.push({
                "x_values": [sum, sum + value],
                "id": input_data[i].id
              });
            } else {
              // numbers.push({i: value});
              stacked.push({
                "x_values": [sum, sum + value],
                "id": input_data[i].id
              });
            } 
            numbers.push(value)
            sum = sum + value;
          }
          x.domain([0, sum]);

          div.select(".summarise_input")
          .html(`According to your input, person 1 does ${numbers[0]} hours of paid work and 
          person 2 does ${numbers[2]} hours. Substracting the ${d3.select("#" + input_data[1].id).property("value")} hours
          your child/children is/are in childcare or school everyday from the typical week, there is still
          98 - 5*${d3.select("#" + input_data[1].id).property("value")} = ${numbers[1]} hours of childcare to do.
          <br>The total working time (paid + care) is ${sum} hours.`)

          let g = d3.select(".working_hours")

          g.selectAll("rect")
            .data(stacked)
            .join("rect")
              .attr("x", d => x(d.x_values[0]))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", d => x(d.x_values[1] - d.x_values[0]))
              .attr("fill", d => work_colour(d.id))
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.id + ": " + Math.round(10*(d.x_values[1] - d.x_values[0]))/10 + " hours");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", work_colour(d.id));
              });
            
          g.selectAll(".label")
              .data(stacked)
              .join("text")
              .attr("class", "label")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", height/2)
              .attr("dy", ".35em")
              .text(d => (d.x_values[1] - d.x_values[0]) > 0 ? (d.x_values[1] - d.x_values[0]) : "");

            g.selectAll(".barlabel")
              .data(stacked)
              .join("text")
              .attr("class", "barlabel")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", 0)
              .attr("dy", "-.35em")
              .text(d => (d.x_values[1] - d.x_values[0]) > 0 ? d.id : "");

          
          g.selectAll(".line")
            .data([""])
            .join("line")
            //.attr("stroke-width",  3)
            // .attr("fill", "none")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", height + 10)
            .attr("y2", height + 10)

          g.selectAll(".ann.axislabel")
            .data([""])
            .join("text")
            .attr("class", "ann axislabel")
            .attr("text-anchor", "middle")
            .attr("x", width/2)
            .attr("y", height + 25)
            .text(sum + " hours");
          
          // text in between
          div.select(".between_svgs")
          .html(`An equal distribution would leave each person with ${sum + "/2 = " + sum/2} working hours.`)
        }

        function load_hours_division (){
          //division hours bar chart
          
          let division_numbers = [];
          let half_hours = sum * total_percentage
          division_numbers[0] = numbers[0]
          division_numbers[1] = half_hours - numbers[0]
          division_numbers[2] = (sum-half_hours) - numbers[2]
          division_numbers[3] = numbers[2]
          
          let division_stacked = [];
          let j = 0;
            for (let i = 0; i < division_numbers.length; i++) {
              division_stacked.push({
                "x_values": [j, j + division_numbers[i]],
                "id": work_division_colour_ids[i]
              });
              j = j + division_numbers[i];
            }
          // console.log(division_numbers)
          // console.log(division_stacked)

          let g_division = d3.select(".working_division")
          g_division.selectAll("rect")
            .data(division_stacked)
            .join("rect")
              .attr("x", d => x(d.x_values[0]))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", d => x(d.x_values[1] - d.x_values[0]))
              .attr("fill", d => work_division_colour(d.id))
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.id + ": " + Math.round(10*(d.x_values[1] - d.x_values[0]))/10 + " hours");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", work_division_colour(d.id));
              });
   
            
          g_division.selectAll("text") //text in middle of rects
            .data(division_stacked)
            .join("text")
              .attr("class", "x axislabel")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", height/2)
              .attr("dy", ".35em")
              .text(d => (d.x_values[1] - d.x_values[0]) > 0 ? Math.round(10*(d.x_values[1] - d.x_values[0]))/10 : "");

          
          g_division.selectAll(".labelline.top")
            .data([[0, width*total_percentage], [width*total_percentage, width]])
            .join("line")
            .attr("class","labelline top")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", d=>d[0])
            .attr("x2", d=>d[1])
            .attr("y1", -10)
            .attr("y2", -10);

            g_division.selectAll(".labelline.bottom")
            .data([[x(numbers[0]), width*total_percentage], [width*total_percentage, x(sum-numbers[2])]])
            .join("line")
            .attr("class","labelline bottom")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", d=>d[0])
            .attr("x2", d=>d[1])
            .attr("y1", height + 10)
            .attr("y2", height + 10);

          
          
          g_division.selectAll(".ann.axislabel.top")
            .data([ 
              // {"x": (width*total_percentage)/2,  "text": Math.round(10*sum*total_percentage)/10 + " hours"},
              // {"x":((width*total_percentage) + (width*(1-total_percentage))/2),  "text": Math.round(10*sum*(1-total_percentage))/10 + " hours"}
              {"x": (width*total_percentage)/2,  "text": Math.round(1000*total_percentage)/10 + "%"},
              {"x":((width*total_percentage) + (width*(1-total_percentage))/2),  "text": Math.round(1000*(1-total_percentage))/10 + "%"}
                  ])
            .join("text")
            .attr("class", "ann axislabel top")
            .attr("text-anchor", "middle")
            .attr("x", d => d.x)
            .attr("y", -18)
            .text(d => d.text);

          g_division.selectAll(".ann.axislabel.bottom")
            .data([ {"x": x(numbers[0] + division_numbers[1]/2),  "text":Math.round((1000*division_numbers[1]/numbers[1]))/10 + "%"},
                    {"x":x(numbers[0] + division_numbers[1] + division_numbers[2]/2),  "text": Math.round((1000*division_numbers[2]/(numbers[1])))/10 + "%"}
                  ])
            .join("text")
            .attr("class", "ann axislabel bottom")
            .attr("text-anchor", "middle")
            .attr("x", d => d.x)
            .attr("y", height + 25)
            .text(d => d.text);

          g_division.selectAll(".barlabel")
            .data([ { "x":width/4, "text": "Person 1"},
                    { "x": 0.75*width, "text": "Person 2"}])
            .join("text")
              .attr("class", "barlabel")
              .attr("text-anchor", "middle")
              .attr("x", d => d.x)
              .attr("y", -30)
              .attr("dy", "-.35em")
            .text(d=>d.text);
            
          // text in between
          div.select(".concl_division")
          .html(`This means that Person 1 would take on ${Math.round((1000*division_numbers[1]/(numbers[1])))/10}% of the childcare hours, which is an overall 
          of ${Math.round(total_percentage*1000)/10}% of all work.
          <br>
          And Person 2 does ${Math.round((1000*division_numbers[2]/(numbers[1])))/10}% of the childcare hours, which is an overall 
          of ${Math.round((1-total_percentage)*1000)/10}% of all working hours.`)
        
          //division line between persons
        d3.select(".working_division").selectAll(".divisionline")
            .data([width*total_percentage])
            .join("line")
            .attr("stroke-width",  2.5)
            // .attr("fill", "none")
            .attr("class","divisionline")
            .attr("stroke", "black")
            .attr("x1", d=>d)
            .attr("x2", d=>d)
            .attr("y1", 0)
            .attr("y2", height)
            .style("cursor", "col-resize")
    
        } 

        //division line between persons
        d3.select(".divisionline")
            .call(d3.drag().on("drag", function (event, d) {
                  d3.select(this)
                   .attr("x1", Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2])));
                   d3.select(this)
                   .attr("x2", Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2])));
                   total_percentage = (Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2]))/width)
                   load_hours_division()
            }))
      }
      //#endregion


      //#region                            #################   functions ##################

      function aggregate_data(data, grouping, person = "me") {
        switch (person) {
          case "me":
            var type_to_use = types
            break;

          case "partner":
            var type_to_use = partner_types
            break;
        }

        let aggregatedData = {
          [type_to_use[0]]: {},
          [type_to_use[1]]: {}
        };
        data.forEach(d => {
          if (d[type_to_use[0]]) {
            aggregatedData[type_to_use[0]][d[grouping]] = (aggregatedData[type_to_use[0]][d[grouping]] || 0) + d.points;
          }
          if (d[type_to_use[1]]) {
            aggregatedData[type_to_use[1]][d[grouping]] = (aggregatedData[type_to_use[1]][d[grouping]] || 0) + d.points;
          }
        });
        let categories = Object.keys(aggregatedData[type_to_use[0]]).concat(Object.keys(aggregatedData[type_to_use[1]])).filter((value, index, self) => self.indexOf(value) === index);



        let formattedData = type_to_use.map(type => {
          const obj = { type };
          categories.forEach(category => {
            obj[category] = aggregatedData[type][category] || 0;
          });
          return obj;
        });


        return [formattedData, type_to_use, categories]
      }



      function remove_weird_symbols(str) {
        return str.replace(/\s/g, "").replace("-", "").replace(",", "").replace("+", "")
      }

      function normaliseMap(map) {
        let map1 = map.get(true);
        let map2 = map.get(false);
        let normalised = new Map ()
        for (let [key, value] of map2.entries()) {
          if(typeof value === 'number') {
            if (map1.has(key)) {
              if (value >= 0) {
                normalised.set(key, (100*(map1.get(key) / (map1.get(key) + value))) | 0);
              } else {
                normalised.set(key, (-100*(map1.get(key) / (map1.get(key) + value))) | 0);
              }
            } else {
              normalised.set(key, 0);
            }
          } else {
            normalised.set(key, new Map())
            for (let [inner_key, value_inner] of value.entries()) {
              if (map1.has(key)) {
                normalised.get(key).set(inner_key, (100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0);
              } else {
                normalised.get(key).set(inner_key, 0);
              }
            }
          }
        }
        return normalised;
        
      }

      function normaliseAndSpecify(map) {
        let map1 = map.get(true);
        let map2 = map.get(false);
        let normalised = new Map ()
        for (let [key, value] of map2.entries()) {
          if(typeof value === 'number') {
            if (map1.has(key)) {
              if (value >= 0) {
                normalised.set(key, [0, ((100*(map1.get(key) / (map1.get(key) + value))) | 0)]);
              } else {
                normalised.set(key, [((-100*(map1.get(key) / (map1.get(key) + value))) | 0), 0]);
              }
            } else {
              normalised.set(key, [0, 0]);
              
            }
          } else {
            normalised.set(key, new Map())
            for (let [inner_key, value_inner] of value.entries()) {
              if (map1.has(key)) {
                if (value_inner >= 0) {
                  normalised.get(key).set(inner_key, [0, ((100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0)]);
                } else {
                  normalised.get(key).set(inner_key, [((-100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0), 0]);
                }
              } else {
                normalised.get(key).set(inner_key, [0,0]);
              }
            }
          }
        }
        return normalised;
        
      }

      function sortInnerMaps(nestedMap) {
        let sortedOuterMap = new Map();
        for (let [outerKey, innerMap] of nestedMap.entries()) {
          // Sort the inner map by its keys
          let sortedInnerMap = new Map([...innerMap.entries()].sort((a, b) => b[1] - a[1]));
          sortedOuterMap.set(outerKey, sortedInnerMap);
        }
        return sortedOuterMap;
      }


      //#endregion
    })

    // .catch(function (error) {
    //   // handle error
    //   console.log(error)
    // });

  </script>




</body>

</html>