<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Load Dev</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
<body>
  
  <!-- Add 2 buttons -->
  <div id="button" height = 50></div>
  <div id="div_template" height = 350></div>
  <div id="stacked_plot" height = 350></div>
  
  
  
  


<script>
    
    // Set up the SVG area and margins
    var margin = { top: 30, right: 20, bottom: 20, left: 60 };
    var width = 500 - margin.left - margin.right;
    var height = 350 - margin.top - margin.bottom;

    var language = "de"

    // append the svg object to the body of the page


d3.json("data/test_json.json").then(function(data_raw) {
  //#region               ###############      variables   #################
  var all_cats = [];
  if (language == "de") {
    var rhythms_points_mapping_de = {"täglich":4,
    "wöchentlich":3,
    "monatlich":2,
    "jährlich":1
  }
  var rhythms = Object.keys(rhythms_points_mapping_de);
}
else if (language == "en") {
    var rhythms_points_mapping_en = {"daily":4,
    "weekly":3,
    "monthly":2,
    "yearly":1
    }
    var rhythms = Object.keys(rhythms_points_mapping_en);
  }
  var types = ["do_it", "remember"]
 
  //#endregion
  
  
  
  
  //#region                    ###############      prep and reshape data            #################
  var questions_final = []; //reshaped data
  var quest_ID = 0;
// target data shape
// {
//     "Wäsche waschen + aufhängen": {
//         "Text": "Wäsche waschen + aufhängen",
//         "ID": "2",
//         "domain": "Alle Sorgegemeinschaften, z.B. Paare",
//         "category":"Haushalt + Wohnen",
//         "rhythm": "täglich",
//         "points": "4.00",
//         "do_it": true,
//         "remember": false,
//         "not_apply": false,
//         "partner_does_it": false,
//         "partner_remembers": true,
//         "do_it_and_remember": false
//     }
// }
let domains = Object.keys(data_raw);
//console.log(domains)
for (let i = 0; i < domains.length; i++) {
  let obj_cats = data_raw[domains[i]]
  let cats = Object.keys(obj_cats)
  //console.log(obj_cats)
  //console.log(cats)
  for (let catId = 0; catId < cats.length; catId++) {
    let obj_rhthm = obj_cats[cats[catId]]
    let rhthms = Object.keys(obj_rhthm)
    //console.log(obj_rhthm)
    //console.log(rhthms)
    //something[catId] = []
    for (let rhtmID = 0; rhtmID < rhthms.length; rhtmID++) {
      let obj_question = obj_rhthm[rhthms[rhtmID]]
      let questions = Object.keys(obj_question)
      //console.log(obj_question)
      //console.log(questions)
        for (let quesID = 0; quesID < questions.length; quesID++) {
          let obj_ques_level_2 = obj_question[questions[quesID]]
          let ques_level_2 =Object.keys(obj_ques_level_2)
          let obj_arr_answers = obj_ques_level_2[ques_level_2[0]]
          //console.log(obj_ques_level_2)
          //console.log(ques_level_2[0])
          //add question to final array, and some more infos we know
          questions_final[quest_ID[0]]=[]
          questions_final.push({})
          questions_final[quest_ID]["Text"] = ques_level_2[0]
          questions_final[quest_ID]["ID"] = questions[quesID]
          questions_final[quest_ID]["domain"] = domains[i]
          questions_final[quest_ID]["category"] = cats[catId]
          questions_final[quest_ID]["rhythm"] = rhthms[rhtmID]
          questions_final[quest_ID]["points"] = rhythms_points_mapping_de[rhthms[rhtmID]]
          
          //either empty array: partner does it, or object with answers 
          if(Array.isArray(obj_arr_answers)) {
            //console.log("partner does it")
            questions_final[quest_ID]["do_it"] = false;
            questions_final[quest_ID]["remember"] = false;
            questions_final[quest_ID]["partner_does_it"] = true;
            questions_final[quest_ID]["partner_remembers"] = true;
            questions_final[quest_ID]["not_apply"] = false;
            questions_final[quest_ID]["do_it_and_remember"] = false;
            //"do_it_and_remember": false//partner +=1
            //partner_rhm +=1
          }
          else{
            let obj_answers = obj_arr_answers //now an object
            let answers =Object.keys(obj_answers)
            //console.log(answers)
            //console.log(obj_answers)
            if (answers.length == 2) { //no need to go into answers, this must be "done" and "remembered"
              questions_final[quest_ID]["do_it"] = true;
              questions_final[quest_ID]["remember"] = true;
              questions_final[quest_ID]["not_apply"] = false;
              questions_final[quest_ID]["partner_does_it"] = false;
              questions_final[quest_ID]["partner_remembers"] = false;
              questions_final[quest_ID]["do_it_and_remember"] = true;
            }
            else {
              questions_final[quest_ID]["do_it_and_remember"] = false;
              let obj_single_answer = obj_answers[answers[0]] //only answer
              //console.log(obj_single_answer)
              //console.log(obj_single_answer["answer_type"])
              switch (obj_single_answer["answer_type"]) {
                case "1": //"do_it"
                  questions_final[quest_ID]["do_it"] = true;
                  questions_final[quest_ID]["remember"] = false;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = true;
                break;
                case "2": //"remember"
                  questions_final[quest_ID]["do_it"] = false;
                  questions_final[quest_ID]["remember"] = true;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = true;
                  questions_final[quest_ID]["partner_remembers"] = false;
                break;
                case "3": //"not_apply"
                  questions_final[quest_ID]["do_it"] = false;
                  questions_final[quest_ID]["remember"] = false;
                  questions_final[quest_ID]["not_apply"] = true;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = false;
                break;
              }
            }
          }
          quest_ID += 1;
        }
      }
    }
        
  }
  //questions_final.forEach((element) => console.log(element));
  //console.table(questions_final)
  //console.table(questions_final.filter(function(d) {return d.remember == true}))
  let valid_questions = questions_final.filter(function(d) {return d.not_apply == false})
  console.table(valid_questions)
  let max_num_points =  d3.sum(valid_questions, (d) => d.points)

  //print some stats of points
  let remembered_questions = questions_final.filter(function(d) {return d.remember == true})
  let done_questions = questions_final.filter(function(d) {return d.do_it == true})
  let not_apply_questions = questions_final.filter(function(d) {return d.not_apply == true})
  let partner_does_it_questions = questions_final.filter(function(d) {return d.partner_does_it == true})
  let partner_remembers_questions = questions_final.filter(function(d) {return d.partner_remembers == true})
  let remembered_points = d3.sum(remembered_questions, (d) => d.points)
  let done_points = d3.sum(done_questions, (d) => d.points)
  let partner_done_points = d3.sum(partner_does_it_questions, (d) => d.points)
  let partner_remembers_points = d3.sum(partner_remembers_questions, (d) => d.points)
  let number_not_apply = d3.count(not_apply_questions, (d) => d.ID)
  //console.log(remembered_points)
  console.log("points done: " + done_points + ", points remembered: " + remembered_points +
    ", points done of partner: " + partner_done_points +
    ", points remembered of partner: " + partner_remembers_points +
    ", number not apply: " + number_not_apply +
    ", max sum of points reachable, for each category: " + max_num_points
  )
  // check validity of data
  if(done_points + partner_done_points != remembered_points +partner_remembers_points ||
  done_points + partner_done_points != max_num_points) {
    throw "something is wrong with the dataset"
  }

  // group by daily, monthly etc. for plots and analysis
  let grouped_by_rhythm = d3.group(valid_questions, d => d.rhythm)


  
//#endregion

//#region                       ##############      setup page    ########
// Initialize the button
var dropdownButton = d3.select("#button")
  .append('select')
dropdownButton // Add a button
  .selectAll('myOptions') // Next 4 lines add 6 options = 6 colors
 	.data(rhythms)
  .enter()
	.append('option')
  .text(function (d) { return d; }) // text showed in the menu
  .attr("value", function (d) { return d; })
  .attr("transform",
"translate(" + margin.left + "," + margin.top + ")")

// svg for plotting 
var svg = d3.select("#div_template")
.append("svg")
.attr("width", width + margin.left + margin.right)
.attr("height", height + margin.top + margin.bottom)
.append("g")
.attr("transform",
"translate(" + margin.left + "," + margin.top + ")")

// X axis
var x = d3.scaleBand()
.range([ 0, width ])
.domain(types)
.padding(0.2);
svg.append("g")
.attr("transform", "translate(0," + height + ")")
.call(d3.axisBottom(x))

// Add Y axis
//initial with max number of points for daily tasks
let filtered_data = grouped_by_rhythm.get(rhythms[0])
let max_num_of_daily_points = d3.sum(filtered_data, (d) => d.points)
  var y = d3.scaleLinear()
    .domain([0, max_num_of_daily_points])
    .range([ height, 0]);
  var yAxis = svg.append("g")
    .attr("class", "myYaxis")
    .call(d3.axisLeft(y));


//#endregion

//#region        ####### vis elements, main ##########


  // svg2.append("g")
  //   .selectAll("g")
  //   // Enter in the stack data = loop key per key = group per group
  //   .data(stackedData)
  //   .enter().append("g")
  //     .attr("fill", function(d) { return color(d.key); })
  //     .selectAll("rect")
  //     // enter a second time = loop subgroup per subgroup to add all rectangles
  //     .data(function(d) { return d; })
  //     .enter().append("rect")
  //       .attr("x", function(d) { return x_stacked(d.data.group); })
  //       .attr("y", function(d) { return y_stacked(d[1]); })
  //       .attr("height", function(d) { return y_stacked(d[0]) - y(d[1]); })
  //       .attr("width",x.bandwidth())
  
 
  //build data array for the first time: "daily as initial"
  console.log(rhythms[0])
  let initial_data = build_data_for_chart(rhythms[0])

  update(initial_data, max_num_of_daily_points);
//#endregion

  //#region                            #################   functions ##################

  // A function that create / update the plot for a given variable:
  function update(data, max_points) {
    
    y.domain([0, max_points]);
    yAxis.transition().duration(1000).call(d3.axisLeft(y));

    var u = svg.selectAll("rect")
      .data(data)
    u
      .enter()
      .append("rect")
      .merge(u)
      .transition()
      .duration(1000)
        .attr("x", function(d) { return x(d.type); })
        .attr("y", function(d) { return y(d.value); })
        .attr("width", x.bandwidth())
        .attr("height", function(d) { return height - y(d.value); })
        .attr("fill", "#69b3a2")

  }

  function build_data_for_chart(option) {
    var data_updated = [];
    let filtered_data = grouped_by_rhythm.get(option)
    types.forEach(ty => {
      //key_value[rh]["types"][ty] = {"type":ty, "value": 0};
      let filtered_data_type = filtered_data.filter(function(d) {return d[ty] == true})
      let num_points = d3.sum(filtered_data_type, (d) => d.points)
      data_updated.push({"type":ty, "value": num_points});
    })
    return data_updated
  }

  dropdownButton.on("change", function(d) {
    // recover the option that has been chosen
    var selectedOption = d3.select(this).property("value")
    // build fitting data
    let data_updated = build_data_for_chart(selectedOption)
    let max_points = d3.sum(grouped_by_rhythm.get(selectedOption), (d) => d.points)
    //console.log(max_points)
    // run the updateChart function with this selected option
    update(data_updated, max_points)
  })
  //#endregion
})

.catch(function(error){
  // handle error
  console.log(error)
});

</script>




</body>
</html>


