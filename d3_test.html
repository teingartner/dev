<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mental Load Dev</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<style>
html *
{
   font-family: "Ubuntu" !important;
}

.tooltip {
    position: absolute;
    text-align: center;
    width: auto;
    height: auto;
    padding: 5px;
    font-size: 12px;
    background: rgb(237, 234, 234);
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
    visibility: hidden; /* Initially hidden */
}


</style>

<body>

  <div id="confusion" height=350></div>
  <div id="tooltip" class="tooltip"></div>
  <div id="button" height=50></div>
  <div id="div_template" height=350></div>
  <p> How are the points calculated? We wanted to weigh the tasks more that are done one a daily basis - 
    in contrast to those which are done only yearly. This is explained with your do-it ticks that you
    set in the test:
  </p>
  <div id="explain_weights" height=350></div>
  <div id="small_multiples" height=350></div>
  






  <script>

    // Set up the SVG area and margins
    var margin = { top: 30, right: 20, bottom: 20, left: 60 };
    var width = 400 - margin.left - margin.right;
    var height = 350 - margin.top - margin.bottom;

    var language = "de"

    // append the svg object to the body of the page


    d3.json("data/test_json.json").then(function (data_raw) {
      //#region               ###############      variables   #################
      var all_cats = [];
      if (language == "de") {
        var rhythms_points_mapping_de = {
          "täglich": 4,
          "wöchentlich": 3,
          "monatlich": 2,
          "jährlich": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_de);
      }
      else if (language == "en") {
        var rhythms_points_mapping_en = {
          "daily": 4,
          "weekly": 3,
          "monthly": 2,
          "yearly": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_en);
      }
      const types = ["do_it", "remember"]
      const partner_types = ["partner_does_it", "partner_remembers"]
      //#endregion

      var color = d3.scaleOrdinal()
          .domain(rhythms)
          .range(['#e41a1c', '#377eb8', '#4daf4a', '#536745'])


    //#region                    ###############      prep and reshape data            #################
      var questions_final = []; //reshaped data
      var quest_ID = 0;
      // target data shape
      // {
      //     "Wäsche waschen + aufhängen": {
      //         "Text": "Wäsche waschen + aufhängen",
      //         "ID": "2",
      //         "domain": "Alle Sorgegemeinschaften, z.B. Paare",
      //         "category":"Haushalt + Wohnen",
      //         "rhythm": "täglich",
      //         "points": "4.00",
      //         "do_it": true,
      //         "remember": false,
      //         "not_apply": false,
      //         "partner_does_it": false,
      //         "partner_remembers": true,
      //         "do_it_and_remember": false
      //     }
      // }
      let domains = Object.keys(data_raw);
      //console.log(domains)
      for (let i = 0; i < domains.length; i++) {
        let obj_cats = data_raw[domains[i]]
        let cats = Object.keys(obj_cats)
        //console.log(obj_cats)
        //console.log(cats)
        for (let catId = 0; catId < cats.length; catId++) {
          let obj_rhthm = obj_cats[cats[catId]]
          let rhthms = Object.keys(obj_rhthm)
          //console.log(obj_rhthm)
          //console.log(rhthms)
          //something[catId] = []
          for (let rhtmID = 0; rhtmID < rhthms.length; rhtmID++) {
            let obj_question = obj_rhthm[rhthms[rhtmID]]
            let questions = Object.keys(obj_question)
            //console.log(obj_question)
            //console.log(questions)
            for (let quesID = 0; quesID < questions.length; quesID++) {
              let obj_ques_level_2 = obj_question[questions[quesID]]
              let ques_level_2 = Object.keys(obj_ques_level_2)
              let obj_arr_answers = obj_ques_level_2[ques_level_2[0]]
              //console.log(obj_ques_level_2)
              //console.log(ques_level_2[0])
              //add question to final array, and some more infos we know
              questions_final[quest_ID[0]] = []
              questions_final.push({})
              questions_final[quest_ID]["Text"] = ques_level_2[0]
              questions_final[quest_ID]["ID"] = questions[quesID]
              questions_final[quest_ID]["domain"] = domains[i]
              questions_final[quest_ID]["category"] = cats[catId]
              questions_final[quest_ID]["rhythm"] = rhthms[rhtmID]
              questions_final[quest_ID]["points"] = rhythms_points_mapping_de[rhthms[rhtmID]]

              //either empty array: partner does it, or object with answers 
              if (Array.isArray(obj_arr_answers)) {
                //console.log("partner does it")
                questions_final[quest_ID]["do_it"] = false;
                questions_final[quest_ID]["remember"] = false;
                questions_final[quest_ID]["partner_does_it"] = true;
                questions_final[quest_ID]["partner_remembers"] = true;
                questions_final[quest_ID]["not_apply"] = false;
                questions_final[quest_ID]["do_it_and_remember"] = false;
                //"do_it_and_remember": false//partner +=1
                //partner_rhm +=1
              }
              else {
                let obj_answers = obj_arr_answers //now an object
                let answers = Object.keys(obj_answers)
                //console.log(answers)
                //console.log(obj_answers)
                if (answers.length == 2) { //no need to go into answers, this must be "done" and "remembered"
                  questions_final[quest_ID]["do_it"] = true;
                  questions_final[quest_ID]["remember"] = true;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = false;
                  questions_final[quest_ID]["do_it_and_remember"] = true;
                }
                else {
                  questions_final[quest_ID]["do_it_and_remember"] = false;
                  let obj_single_answer = obj_answers[answers[0]] //only answer
                  //console.log(obj_single_answer)
                  //console.log(obj_single_answer["answer_type"])
                  switch (obj_single_answer["answer_type"]) {
                    case "1": //"do_it"
                      questions_final[quest_ID]["do_it"] = true;
                      questions_final[quest_ID]["remember"] = false;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = true;
                      break;
                    case "2": //"remember"
                      questions_final[quest_ID]["do_it"] = false;
                      questions_final[quest_ID]["remember"] = true;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = true;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                    case "3": //"not_apply"
                      questions_final[quest_ID]["do_it"] = false;
                      questions_final[quest_ID]["remember"] = false;
                      questions_final[quest_ID]["not_apply"] = true;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                  }
                }
              }
              quest_ID += 1;
            }
          }
        }

      }
      //questions_final.forEach((element) => console.log(element));
      //console.table(questions_final)
      //console.table(questions_final.filter(function(d) {return d.remember == true}))
      let valid_questions = questions_final.filter(function (d) { return d.not_apply == false })
      //console.table(valid_questions)
      let max_num_points = d3.sum(valid_questions, (d) => d.points)

      //print some stats of points
      let remembered_questions = questions_final.filter(function (d) { return d.remember == true })
      let done_questions = questions_final.filter(function (d) { return d.do_it == true })
      let not_apply_questions = questions_final.filter(function (d) { return d.not_apply == true })
      let partner_does_it_questions = questions_final.filter(function (d) { return d.partner_does_it == true })
      let partner_remembers_questions = questions_final.filter(function (d) { return d.partner_remembers == true })
      let remembered_points = d3.sum(remembered_questions, (d) => d.points)
      let done_points = d3.sum(done_questions, (d) => d.points)
      let partner_done_points = d3.sum(partner_does_it_questions, (d) => d.points)
      let partner_remembers_points = d3.sum(partner_remembers_questions, (d) => d.points)
      let number_not_apply = d3.count(not_apply_questions, (d) => d.ID)
      // group by daily, monthly etc. for plots and analysis
      let grouped_by_rhythm = d3.group(valid_questions, d => d.rhythm)

      const uniqueCategories = Array.from(new Set(valid_questions.map(d => d.category)));
      const uniqueDomains = Array.from(new Set(valid_questions.map(d => d.domain)));
      console.log(uniqueDomains)
      console.log("points done: " + done_points + ", points remembered: " + remembered_points +
        ", points done of partner: " + partner_done_points +
        ", points remembered of partner: " + partner_remembers_points +
        ", number not apply: " + number_not_apply +
        ", max sum of points reachable, for each category: " + max_num_points
      )
      // check validity of data
      if (done_points + partner_done_points != remembered_points + partner_remembers_points ||
        done_points + partner_done_points != max_num_points) {
        throw "something is wrong with the dataset"
      }

      //#endregion

    //#region        ########## confusion matrix ###########
      console.table(valid_questions)
      var conf_margin = { top: 30, right: 250, bottom: 20, left: 20 };
      var conf_width = 800 - conf_margin.left - conf_margin.right;
      var conf_height = 400 - conf_margin.top - conf_margin.bottom;
      
      var domainColor = d3.scaleOrdinal()
          .domain(uniqueDomains)
          .range(['#F0E15B', '#5BD8F0', '#9B966E', '#F05B9B'])

      const innerWidth = conf_width - conf_margin.left - conf_margin.right;
      const innerHeight = conf_height - conf_margin.top - conf_margin.bottom;

      const x_confusion = d3.scaleBand()
        .domain(['remember', 'partner_remembers'])
        .range([0, innerWidth]);

      const y_confusion = d3.scaleBand()
        .domain(['do_it', 'partner_does_it'])
        .range([0, innerHeight]);

      const svg_confusion  = d3.select("#confusion")
      .append("svg")
        .attr("width", conf_width)
        .attr("height", conf_height)
        .append("g")
        .attr("transform", `translate(${conf_margin.left},${conf_margin.top})`);

      // const gridSize = x_confusion.bandwidth();
      // const cells = svg_confusion.selectAll(".cell")
      //   .data(y_confusion.domain().flatMap(row => x_confusion.domain().map(col => ({row, col}))))
      //   .enter().append("rect")
      //   .attr("class", "cell")
      //   .attr("x", d => x_confusion(d.col))
      //   .attr("y", d => y_confusion(d.row))
      //   .attr("width", gridSize)
      //   .attr("height", gridSize);

      // Add column labels
      svg_confusion.selectAll(".column-label")
        .data(x_confusion.domain())
        .enter().append("text")
        .attr("class", "column-label")
        .attr("x", d => x_confusion(d) + x_confusion.bandwidth() / 2)
        .attr("y", -10) // Position above the grid
        .attr("text-anchor", "middle")
        .text(d => d);

      // Add row labels
      svg_confusion.selectAll(".row-label")
        .data(y_confusion.domain())
        .enter().append("text")
        .attr("class", "row-label")
        .attr('transform', d => 'translate('+ -10 +','+ (y_confusion(d) + y_confusion.bandwidth() / 2) +'),'+ 'rotate(-90)')
        //.text(function(d) {console.log(y_confusion.bandwidth() / 2)})
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em") // Vertical alignment
        .text(d => d);

      // calculate radius based on points
      const radiusScale = d3.scaleSqrt()
        .domain([0, d3.max(valid_questions, d => d.points)])
        .range([0, 10]);

      // Map data to cell positions
      const mappedData = valid_questions.map(d => ({
        ...d,
        x: x_confusion(d.remember ? "remember" : "partner_remembers") + x_confusion.bandwidth() / 2,
        y: y_confusion(d.do_it ? "do_it" : "partner_does_it") + y_confusion.bandwidth() / 2,
        r: radiusScale(d.points)
      }));

      // Create simulation
      const simulation = d3.forceSimulation(mappedData)
        .force("x", d3.forceX(d => d.x).strength(1))
        .force("y", d3.forceY(d => d.y).strength(1))
        .force("collide", d3.forceCollide(d => d.r))
        .stop();

      for (let i = 0; i < 500; ++i) simulation.tick(); // Run the simulation
      const tooltip = d3.select("#tooltip");
      // Draw points
      svg_confusion.append("g").selectAll(".point")
        .data(mappedData)
        .enter().append("circle")
        .attr("class", "point")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", d => d.r)
        .style("fill", d => domainColor(d.domain))
        .on("mouseover", function(event, d) {
          tooltip.style("visibility", "visible").text(d.Text);
          d3.select(this).attr("stroke", "darkgrey").attr("stroke-width", 1.5)
          })
        .on("mousemove", function(event, d) {
          tooltip.style("top", (event.pageY - 10) + "px")
          .style("left", (event.pageX + 10) + "px");
        })
        .on("mouseout", function(event, d) {
          d3.select(this).attr("stroke", "none");
          tooltip.style("visibility", "hidden");
  });


      // legend
      const legend = svg_confusion.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${innerWidth + 40}, 20)`);

      // Add size legend
      const sizeLegend = legend.append("g")
        .attr("class", "size-legend");

      sizeLegend.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .text("Size (Frequency):")
        .style("font-size", "12px")
        .style("font-weight", "bold");

      const sizeValues = [...new Set(valid_questions.map(d => d.points))];

      sizeLegend.selectAll("circle")
        .data(sizeValues)
        .enter().append("circle")
        .attr("cx", 10)
        .attr("cy", (d, i) => 20 + i * 25)
        .attr("r", d => radiusScale(d))
        .attr("fill", "none")
        .attr("stroke", "black");

      sizeLegend.selectAll("text.size-label")
        .data(sizeValues)
        .enter().append("text")
        .attr("class", "size-label")
        .attr("x", 30)
        .attr("y", (d, i) => 20 + i * 25)
        .attr("dy", "0.35em")
        .style("font-size", "12px")
        .text(d => rhythms[Math.abs(d-4)]);

      // Add color legend
      const colorLegend = legend.append("g")
        .attr("class", "color-legend")
        .attr("transform", "translate(0, 150)");

      colorLegend.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .text("Color (Domain):")
        .style("font-size", "12px")
        .style("font-weight", "bold");

      const domainValues = [...new Set(valid_questions.map(d => d.domain))];

      colorLegend.selectAll("rect")
        .data(domainValues)
        .enter().append("rect")
        .attr("x", 10)
        .attr("y", (d, i) => 20 + i * 20)
        .attr("width", 10)
        .attr("height", 10)
        .attr("fill", d => domainColor(d));

      colorLegend.selectAll("text.color-label")
        .data(domainValues)
        .enter().append("text")
        .attr("class", "color-label")
        .attr("x", 30)
        .attr("y", (d, i) => 25 + i * 20) // Adjust y to vertically center with the rect
        .attr("dy", "0.35em")
        .text(d => d)
        .style("font-size", "12px"); // Ensure the text size is visible
  

      var mouseleave = function(d) {
        //textSvg1.style("opacity", 0)
        d3.select(this)
          .style("stroke", "none")
          .style("opacity", 0.8)
      }



    //#endregion


    //#region                       ##############      overview chart    ########

      //#endregion

    //#region                       ##############      explain points  ########
      var svg3 = d3.select("#explain_weights")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("class", "explain_svg")
          .attr("position", "absolute")
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")
      
      var x_explain = d3.scaleBand()
          .range([0, width])
          .domain(["ticks", "points"])
          .paddingInner(0.5)
          .paddingOuter(0.5)
          

      var xAxis_explain = svg3.append("g")
          //.attr("transform", "translate(0,)")
          .call(d3.axisTop(x_explain))
      xAxis_explain.selectAll("path")
          .style("stroke", "none");

      var y_explain = d3.scaleLinear()
          .domain([done_points, 0])
          .range([height, 0]);
      svg3.append("g")
          .attr("transform", "translate(" + (width - 0.8*x_explain.paddingOuter()*x_explain.step()) + ",0)")
          .call(d3.axisRight(y_explain));
      
      //aggregate according to points
      var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")
      
      
      var stack = d3.stack()
        .keys(categories)
        .order(d3.stackOrderReverse)
        .offset(d3.stackOffsetNone);

      // aggregate by number of ticks
      var ticks_by_rhythm = d3.rollup(done_questions, v  => v.length, d => d.rhythm)
      let formatted_ticks = { };
      let done_ticks = 0;
      rhythms.forEach(rhythm => {
        formatted_ticks[rhythm] = ticks_by_rhythm.get(rhythm) || 0;
        done_ticks += ticks_by_rhythm.get(rhythm) || 0
      });
      //console.log(done_ticks)
      //join ticks and points
      formattedData[1] = formatted_ticks
      var series = stack(formattedData) //stack data
      series.forEach(item => {
        item[0].data["type"] = "points"
        item[1].data["type"] = "ticks"
      })

      // data for lines
      var connection_lines = []
      series.forEach((item, index) => {
        connection_lines[index]=[item[1][1], item[0][1]]
      })
      var fraction_lines = []
      let i = 0;
      series.forEach((item, index) => {
        switch (item.key) {
          case rhythms[3]: //yearly
            fraction_lines[i] = item[0][1]
            i++;
            break;
          case rhythms[2]: //monthly
            fraction_lines[i] = item[0][1]
            fraction_lines[i+1] = item[0][0] + (item[1][1]-item[1][0])
            i+=2;
            break;
          case rhythms[1]: //weekly
            fraction_lines[i] = item[0][1]
            fraction_lines[i+1] = item[0][0] + (item[1][1]-item[1][0])
            fraction_lines[i+2] = item[0][0] + 2*(item[1][1]-item[1][0])
            i+=3;
            break;
          case rhythms[0]: //daily
            fraction_lines[i] = item[0][1]
            fraction_lines[i+1] = item[0][0] + (item[1][1]-item[1][0])
            fraction_lines[i+2] = item[0][0] + 2*(item[1][1]-item[1][0])
            fraction_lines[i+3] = item[0][0] + 3*(item[1][1]-item[1][0])
            i+=4;
            break;
          default:
            break;
        }
        //fraction_lines[i]=[item[1][1], item[0][1]]
       
      })

      svg3.append("g")
        .selectAll("g")
        .data(series)
        .enter().append("g")
        .attr("class", "serie")
        .attr("fill", d => color(d.key))
        //.text(function(d) {console.log(d)})
        .selectAll("rect")
        .data(d => d)
        .enter().append("rect")
        .attr("x", d => x_explain(d.data.type))
        .attr("y", d => y_explain(d[0]))
        .attr("height", d => y_explain(d[1]) - y_explain(d[0]))
        .attr("width", x_explain.bandwidth());

      //lines
      svg3
        .select("g")
        .selectAll("line.connection_line")
        .data(connection_lines)
        .enter()
        .append("line")
          .attr("class", "connection_line")
          //.text(function(d) {console.log(d)})
          .style("stroke", "black")
          .attr("x1", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          .attr("y1", (d) => y_explain(d[0]))
          .attr("y2", (d) => y_explain(d[1]));

      svg3.append("g")
        .selectAll("line.fraction_line")
        .data(fraction_lines)
        .enter()
        .append("line")
          .attr("class", "fraction_line")
          //.text(function(d) {console.log(d)})
          .style("stroke", "black")
          .style("stroke-dasharray", ("4, 4"))
          .style("stroke-width", 0.5)
          // .attr("x1", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          // .attr("x2", x_explain.paddingOuter()*x_explain.step() + 2*x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          .attr("x1", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter()*x_explain.step() + 2*x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          .attr("y1", (d) => y_explain(d))
          .attr("y2", (d) => y_explain(d));

      svg3.append("g")
        .selectAll("text.multiplier")
        .data(series)
        .enter()
        .append("text")
        .attr("class", "multiplier")
        .attr("x", width/2)
        .attr("y", (d) => y_explain(((d[1][0] + (d[1][1]-d[1][0])/2) +(d[0][0] + (d[0][1]-d[0][0])/2))/2 ))
        .attr("dy", ".35em")
        .style("text-anchor", "middle")
        .style("font-family", "Ubuntu")
        .style("font-size", "80%")
        .text(d => "x" + (d.index+1));

      svg3.append("g")
        .selectAll("text.legend")
        .data(series)
        .enter()
        .append("text")
        .attr("class", "legend")
        //.text(function(d) {console.log(d)})
        .attr("x",x_explain.paddingOuter()*x_explain.step())
        .attr("y", (d) => y_explain(d[1][0] + (d[1][1]-d[1][0])/2))
        .attr("dx", "-.35em")
        .attr("dy", ".35em")
        .style("text-anchor", "end")
        .style("font-family", "Ubuntu")
        .style("font-size", "80%")
        .text(d => d.key);
      
      svg3.append("g")
        .selectAll("text.sum")
        .data([{"sum":done_points, "type":"points"}, {"sum":done_ticks, "type":"ticks"}])
        .enter()
        .append("text")
        .attr("class", "sum")
        //.text(function(d) {console.log(d)})
        .attr("x", (d) => x_explain(d.type) + x_explain.bandwidth()/2)
        .attr("y", (d) => y_explain(d.sum))
        .attr("dy", "1.2em")
        .style("text-anchor", "middle")
        .style("font-family", "Ubuntu")
        .style("font-size", "80%")
        .text(d => d.sum);
      

      //#endregion

      
      //#region                       ##############      split by rhythm   ########
      // color palette = one color per subgroup
      

      //             ##### stacked plot #####
      var rhythms_button = d3.select("#small_multiples")
      .append('select')
      rhythms_button // Add a button
      .selectAll('myOptions') //
      .data(["stacked", "small_multiples"])
      .enter()
        .append('option')
        .text(function (d) { return d; }) // text showed in the menu
        .attr("value", function (d) { return d; })
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      rhythms_button.on("change", function (d) {
        // recover the option that has been chosen
        let selectedOption = d3.select(this).property("value")
        build_rhythms_chart(selectedOption)
      })



      function build_rhythms_chart(option = "stacked") {
      
        // call functions 
        var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")
        var stack = d3.stack()
            .keys(categories)
            .order(d3.stackOrderNone)
            .offset(d3.stackOffsetNone);

        var series = stack(formattedData);
        console.table(series)
        let div_class = "#small_multiples";
        let new_class = "small_multiples_content";
        d3.selectAll(".small_multiples_content").remove()

        if (option == "stacked") {
          build_stacked_chart(series, type, div_class, new_class)
        }
        else {
          build_multiples_chart()
        }
      }

      
      // functions
      function build_stacked_chart(series, type, div_class, new_class) {
        var svg2 = d3.select(div_class)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("class", new_class)
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        var x_stacked = d3.scaleBand()
          .range([0, width])
          .domain(type)
          .padding(0.2);
        var xAxis_stacked = svg2.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x_stacked))

        // Add Y axis
        var y_stacked = d3.scaleLinear()
          .domain([0, Math.max(done_points, remembered_points, max_num_points)])
          .range([height, 0]);
        svg2.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y_stacked));

        x_stacked.domain(type)
        xAxis_stacked.transition().duration(1000).call(d3.axisBottom(x_stacked));

        svg2.append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(series)
          .enter().append("g")
          .attr("class", "serie")
          .attr("fill", d => color(d.key))
          //.text(function(d) {console.log(d)})
          .selectAll("rect")
          .data(d => d)
          .enter().append("rect")
          .attr("x", d => x_stacked(d.data.type))
          .attr("y", d => y_stacked(d[1]))
          //.text(function(d) {console.log(d)})
          .attr("height", d => y_stacked(d[0]) - y_stacked(d[1]))
          .attr("width", x_stacked.bandwidth());

        const legend = svg2.selectAll(".legend")
          .data(rhythms.slice().reverse())
          .enter().append("g")
          .attr("class", "legend")
          .attr("transform", (d, i) => `translate(0,${i * 20})`);

        legend.append("rect")
          .attr("x", width - 18)
          .attr("width", 18)
          .attr("height", 18)
          .style("fill", color);

        legend.append("text")
          .attr("x", width - 24)
          .attr("y", 9)
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .style("font-family", "calibri")
          .style("font-size", "80%")
          .text(d => d);
        
        
      }
      
      function aggregate_data(data,grouping, person = "me" , aggr = "points") {
        switch (person) {
          case "me":
            var type_to_use = types
            break;

          case "partner":
            var type_to_use = partner_types
            break;
        }

        let aggregatedData = {
          [type_to_use[0]]: {},
          [type_to_use[1]]: {}
        };
        data.forEach(d => {
          if (d[type_to_use[0]]) {
            aggregatedData[type_to_use[0]][d[grouping]] = (aggregatedData[type_to_use[0]][d[grouping]] || 0) + d.points;
          }
          if (d[type_to_use[1]]) {
            aggregatedData[type_to_use[1]][d[grouping]] = (aggregatedData[type_to_use[1]][d[grouping]] || 0) + d.points;
          }
        });
        let categories = Object.keys(aggregatedData[type_to_use[0]]).concat(Object.keys(aggregatedData[type_to_use[1]])).filter((value, index, self) => self.indexOf(value) === index);

        

        let formattedData = type_to_use.map(type => {
          const obj = { type };
          categories.forEach(category => {
            obj[category] = aggregatedData[type][category] || 0;
          });
          return obj;
        });
        

        return [formattedData, type_to_use, categories]
      }


      function build_multiples_chart() {

      // var multiples_button = d3.select("#small_multiples")
      // .append('input')
      // .attr("type", "checkbox")
      // .attr("class", "small_multiples_content")
      // .text("say something")
      // .attr("transform",
      //     "translate(" + margin.left + "," + margin.top + ")")


      // multiples_button.on("change", function (d) {
      //   if(this.checked) {
      //     console.log("checked")
      //   }
      // })
      //console.table(grouped_by_rhythm)
      let group_test = d3.group(valid_questions, d => d.rhythm, d => d.remember)
        let group_test_do_it = d3.group(valid_questions, d => d.rhythm, d => d.do_it)
        //console.table(group_test.get("täglich"))
        let do_it_points = []
        let remember_points = []
        group_test.forEach(function(value,key) {
          value.delete(false)
          let to_rename = value.get(true)
          value.set("remember", to_rename)
          value.delete(true)
          let do_it = group_test_do_it.get(key)
          //console.log(do_it)
          value.set("do_it", do_it.get(true))
          do_it_points.push(d3.sum(value.get("do_it"), (d) => d.points))
          remember_points.push(d3.sum(value.get("remember"), (d) => d.points))
          
        })
        

        var small_multiples_width = width/2
        var svg_multiples = d3.select("small_multiples")
          .data(group_test)
          .enter()
          .append("svg")
            .attr("width", small_multiples_width + margin.left + margin.right)
            .attr("height", small_multiples_width + margin.top + margin.bottom)
            .attr("class","small_multiples_content")
            //.text(function(d) {console.log(d[0])})
            //.text(function(d) {console.log(d);})
          .append("g")
            .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", function(d) { return d[0];})

        // X axis
        var x_multiples = d3.scaleBand()
          .range([0, small_multiples_width])
          .domain(types)
          .padding(0.1);
        svg_multiples.append("g")
          .attr("transform", "translate(0," + small_multiples_width + ")")
          .call(d3.axisBottom(x_multiples))

        
        // Add Y axis
        let max_reachable_points_per_rhythm = []
        rhythms.forEach(function(v){
          //console.log(v)
          max_reachable_points_per_rhythm.push(d3.sum(grouped_by_rhythm.get(v), (d) => d.points))
        })
        console.log(Math.max(...do_it_points.concat(remember_points)))
        var y_multiples = d3.scaleLinear()
          .domain([0, Math.max(...do_it_points.concat(remember_points, max_reachable_points_per_rhythm))+20]) 
          .range([small_multiples_width, 0]);
          svg_multiples.append("g")
          .attr("class", "myYaxis_multiples")
          .call(d3.axisLeft(y_multiples));

      group_test.forEach(function(data, i) {
      let max_points = d3.sum(grouped_by_rhythm.get(i), (d) => d.points)
        //console.log(data, i)
        d3.select("g." + i)
        .selectAll('.bar')
        .data(data)
          .enter()
            .append("rect")
            //.text(function(d) {console.log(d)})
            .attr("x", function (d) { return x_multiples(d[0]); })
            .attr("y", function (d) { return y_multiples(d3.sum(d[1], (s) => s.points));})
            // .text(function(d) {
            //   console.log(d3.sum(d[1], (s) => s.points));
            //   // d3.sum(remembered_questions, (d) => d.points)
            //                   console.log(d)
            // })
            .attr("width", x_multiples.bandwidth())
            .attr("height", function (d) { return small_multiples_width - y_multiples(d3.sum(d[1], (s) => s.points)); })
            .attr("fill", d => color(i) )
        
        d3.select("g." + i)
          .append("line")
              .attr("class", "some_line")
              //.text(function(d) {console.log(d)})
          .style("stroke", "grey")
          .attr("x1", 0)
          .attr("x2", small_multiples_width)
          .attr("y1", (d) => y_multiples(max_points))
          .attr("y2", (d) => y_multiples(max_points));
        
          d3.select("g." + i).append("text")
          .attr("x", (small_multiples_width / 2))             
          .attr("y", 0 - (margin.top / 3))
          .attr("text-anchor", "middle")  
          .style("font-family", "calibri")
          .style("font-size", "100%") 
          .text(i);

          d3.select("g." + i).append("text")
          .attr("x", small_multiples_width * (1 / 2))
          .attr("y", (d) => y_multiples(max_points))
          .attr("dy", "-.35em")
          .attr("text-anchor", "middle")
          .style("font-family", "calibri")
          .style("font-size", "80%")
          .text("max reachable points")
        
      })
      }

      //#endregion
      function build_categories_chart(option = "stacked") {
      
        // call functions 
        var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "category")
        
        var stack = d3.stack()
            .keys(categories)
            .order(d3.stackOrderNone)
            .offset(d3.stackOffsetNone);

        var series = stack(formattedData);
        //console.table(formattedData)
        d3.selectAll(".summet").remove()
        let div_class = "small_multiples_categories"
        let new_class = "summet"
        if (option == "stacked") {
          build_stacked_chart(series, type, div_class, new_class)
        }
        else {
          build_multiples_chart()
        }
      }
      
      //#region                       ##############      setup page    ########
      // Initialize the button
      var dropdownButton = d3.select("#button")
        .append('select')
      dropdownButton // Add a button
        .selectAll('myOptions') // Next 4 lines add 6 options = 6 colors
        .data(rhythms)
        .enter()
        .append('option')
        .text(function (d) { return d; }) // text showed in the menu
        .attr("value", function (d) { return d; })
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      // svg for plotting 
      var svg = d3.select("#div_template")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(types)
        .padding(0.2);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))

      // Add Y axis
      //initial with max number of points for daily tasks
      let filtered_data = grouped_by_rhythm.get(rhythms[0])
      let max_num_of_daily_points = d3.sum(filtered_data, (d) => d.points)
      var y = d3.scaleLinear()
        .domain([0, max_num_of_daily_points])
        .range([height, 0]);
      var yAxis = svg.append("g")
        .attr("class", "myYaxis")
        .call(d3.axisLeft(y));

    
      //#endregion


      //#region        ####### vis elements, main ##########


      //build data array for the first time: "daily as initial"
      // console.log(rhythms[0])
      let initial_data = build_data_for_chart(rhythms[0])
      // svg.append("g").attr("class", "content");

      update(initial_data, max_num_of_daily_points);
      // build_rhythms_chart("stacked")
      build_categories_chart("stacked")

      

      //#endregion

      //#region                            #################   functions ##################

      // A function that create / update the plot for a given variable:
      function update(data, max_points) {

        y.domain([0, max_points]);
        yAxis.transition().duration(1000).call(d3.axisLeft(y));

        var u = svg.selectAll(".content")
          .data(data);
        u.exit().remove();

        var enter = u.enter().append("g").attr("class", "content");
        enter.append("rect").attr("class", "rectangle");
        enter.append("line").attr("class", "myLine");
        enter.append("text").attr("class", "line_label");

        u = u.merge(enter)
        u.select(".rectangle")
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.type); })
          .attr("y", function (d) { return y(d.value); })
          //.text(function(d) {console.log(d.type);})
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", "#69b3a2")

        u.select(".myLine")
          .transition()
          .duration(1000)
          .style("stroke", "grey")
          .style("stroke-dasharray", ("4, 4"))
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", (d) => y(max_points / 2))
          .attr("y2", (d) => y(max_points / 2));

        u.select(".line_label")
          .transition()
          .duration(1000)
          .attr("x", width * (2 / 3))
          .attr("y", (d) => y(max_points / 2))
          .attr("dy", "-.35em")
          .style("font-family", "calibri")
          .style("font-size", "80%")
          .text("50% of points")

      }

      function build_data_for_chart(option) {
        let data_updated = [];
        let filtered_data = grouped_by_rhythm.get(option)
        types.forEach(ty => {
          //key_value[rh]["types"][ty] = {"type":ty, "value": 0};
          let filtered_data_type = filtered_data.filter(function (d) { return d[ty] == true })
          let num_points = d3.sum(filtered_data_type, (d) => d.points)
          data_updated.push({ "type": ty, "value": num_points });
        })
        return data_updated
      }

      dropdownButton.on("change", function (d) {
        // recover the option that has been chosen
        let selectedOption = d3.select(this).property("value")
        // build fitting data
        let data_updated = build_data_for_chart(selectedOption)
        let max_points = d3.sum(grouped_by_rhythm.get(selectedOption), (d) => d.points)
        //console.log(max_points)
        // run the updateChart function with this selected option
        update(data_updated, max_points)
      })

      // ##### functions for data handling #### 

      
      //#endregion
    })

      // .catch(function (error) {
      //   // handle error
      //   console.log(error)
      // });

  </script>




</body>

</html>